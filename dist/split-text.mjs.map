{"version":3,"file":"split-text.mjs","names":[],"sources":["../src/split-text.ts"],"sourcesContent":["/**\n * Recursive markdown text splitter (LangChain-style)\n */\n\nconst MARKDOWN_SEPARATORS = [\n  '\\n## ',\n  '\\n### ',\n  '\\n#### ',\n  '\\n##### ',\n  '\\n###### ',\n  '```\\n\\n',\n  '\\n\\n***\\n\\n',\n  '\\n\\n---\\n\\n',\n  '\\n\\n___\\n\\n',\n  '\\n\\n',\n  '\\n',\n  ' ',\n  '',\n]\n\nexport interface SplitTextOptions {\n  chunkSize?: number\n  chunkOverlap?: number\n  separators?: string[]\n}\n\nexport interface TextChunk {\n  text: string\n  index: number\n  /** Character range [start, end] in original text */\n  range: [number, number]\n  /** Line range [startLine, endLine] (1-indexed) */\n  lines: [number, number]\n}\n\n/**\n * Convert character offset to line number (1-indexed)\n */\nfunction offsetToLine(text: string, offset: number): number {\n  let line = 1\n  for (let i = 0; i < offset && i < text.length; i++) {\n    if (text[i] === '\\n')\n      line++\n  }\n  return line\n}\n\n/**\n * Split text recursively using markdown-aware separators\n */\nexport function splitText(\n  text: string,\n  options: SplitTextOptions = {},\n): TextChunk[] {\n  const {\n    chunkSize = 1000,\n    chunkOverlap = 200,\n    separators = MARKDOWN_SEPARATORS,\n  } = options\n\n  if (text.length <= chunkSize) {\n    const endLine = offsetToLine(text, text.length)\n    return [{ text, index: 0, range: [0, text.length], lines: [1, endLine] }]\n  }\n\n  const chunks = splitRecursive(text, chunkSize, separators)\n  return mergeChunks(chunks, chunkSize, chunkOverlap, text)\n}\n\nfunction splitRecursive(\n  text: string,\n  chunkSize: number,\n  separators: string[],\n): string[] {\n  if (text.length <= chunkSize || separators.length === 0) {\n    return [text]\n  }\n\n  const separator = separators.find(sep => sep === '' || text.includes(sep))\n  if (!separator && separator !== '') {\n    return [text]\n  }\n\n  const parts = separator === '' ? [...text] : text.split(separator)\n  const results: string[] = []\n\n  for (let i = 0; i < parts.length; i++) {\n    const part = parts[i]!\n    const withSep = i < parts.length - 1 && separator !== ''\n      ? part + separator\n      : part\n\n    if (withSep.length <= chunkSize) {\n      results.push(withSep)\n    }\n    else {\n      // Recurse with remaining separators\n      const subParts = splitRecursive(withSep, chunkSize, separators.slice(1))\n      results.push(...subParts)\n    }\n  }\n\n  return results\n}\n\nfunction mergeChunks(\n  parts: string[],\n  chunkSize: number,\n  chunkOverlap: number,\n  originalText: string,\n): TextChunk[] {\n  const chunks: TextChunk[] = []\n  let current = ''\n  let currentStart = 0\n\n  for (const part of parts) {\n    if (current.length + part.length <= chunkSize) {\n      current += part\n    }\n    else {\n      if (current) {\n        const start = originalText.indexOf(current, currentStart)\n        const actualStart = start >= 0 ? start : currentStart\n        const actualEnd = actualStart + current.length\n        chunks.push({\n          text: current,\n          index: chunks.length,\n          range: [actualStart, actualEnd],\n          lines: [offsetToLine(originalText, actualStart), offsetToLine(originalText, actualEnd)],\n        })\n        currentStart = Math.max(0, actualStart + current.length - chunkOverlap)\n      }\n\n      // Start new chunk, possibly with overlap from previous\n      if (chunkOverlap > 0 && current.length > chunkOverlap) {\n        const overlap = current.slice(-chunkOverlap)\n        current = overlap + part\n      }\n      else {\n        current = part\n      }\n    }\n  }\n\n  // Don't forget the last chunk\n  if (current) {\n    const start = originalText.indexOf(current, currentStart)\n    const actualStart = start >= 0 ? start : currentStart\n    const actualEnd = start >= 0 ? start + current.length : originalText.length\n    chunks.push({\n      text: current,\n      index: chunks.length,\n      range: [actualStart, actualEnd],\n      lines: [offsetToLine(originalText, actualStart), offsetToLine(originalText, actualEnd)],\n    })\n  }\n\n  return chunks\n}\n"],"mappings":"AAIA,MAAM,sBAAsB;CAC1B;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACD;AAoBD,SAAS,aAAa,MAAc,QAAwB;CAC1D,IAAI,OAAO;AACX,MAAK,IAAI,IAAI,GAAG,IAAI,UAAU,IAAI,KAAK,QAAQ,IAC7C,KAAI,KAAK,OAAO,KACd;AAEJ,QAAO;;AAMT,SAAgB,UACd,MACA,UAA4B,EAAE,EACjB;CACb,MAAM,EACJ,YAAY,KACZ,eAAe,KACf,aAAa,wBACX;AAEJ,KAAI,KAAK,UAAU,WAAW;EAC5B,MAAM,UAAU,aAAa,MAAM,KAAK,OAAO;AAC/C,SAAO,CAAC;GAAE;GAAM,OAAO;GAAG,OAAO,CAAC,GAAG,KAAK,OAAO;GAAE,OAAO,CAAC,GAAG,QAAQ;GAAE,CAAC;;AAI3E,QAAO,YADQ,eAAe,MAAM,WAAW,WAAW,EAC/B,WAAW,cAAc,KAAK;;AAG3D,SAAS,eACP,MACA,WACA,YACU;AACV,KAAI,KAAK,UAAU,aAAa,WAAW,WAAW,EACpD,QAAO,CAAC,KAAK;CAGf,MAAM,YAAY,WAAW,MAAK,QAAO,QAAQ,MAAM,KAAK,SAAS,IAAI,CAAC;AAC1E,KAAI,CAAC,aAAa,cAAc,GAC9B,QAAO,CAAC,KAAK;CAGf,MAAM,QAAQ,cAAc,KAAK,CAAC,GAAG,KAAK,GAAG,KAAK,MAAM,UAAU;CAClE,MAAM,UAAoB,EAAE;AAE5B,MAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;EACrC,MAAM,OAAO,MAAM;EACnB,MAAM,UAAU,IAAI,MAAM,SAAS,KAAK,cAAc,KAClD,OAAO,YACP;AAEJ,MAAI,QAAQ,UAAU,UACpB,SAAQ,KAAK,QAAQ;OAElB;GAEH,MAAM,WAAW,eAAe,SAAS,WAAW,WAAW,MAAM,EAAE,CAAC;AACxE,WAAQ,KAAK,GAAG,SAAS;;;AAI7B,QAAO;;AAGT,SAAS,YACP,OACA,WACA,cACA,cACa;CACb,MAAM,SAAsB,EAAE;CAC9B,IAAI,UAAU;CACd,IAAI,eAAe;AAEnB,MAAK,MAAM,QAAQ,MACjB,KAAI,QAAQ,SAAS,KAAK,UAAU,UAClC,YAAW;MAER;AACH,MAAI,SAAS;GACX,MAAM,QAAQ,aAAa,QAAQ,SAAS,aAAa;GACzD,MAAM,cAAc,SAAS,IAAI,QAAQ;GACzC,MAAM,YAAY,cAAc,QAAQ;AACxC,UAAO,KAAK;IACV,MAAM;IACN,OAAO,OAAO;IACd,OAAO,CAAC,aAAa,UAAU;IAC/B,OAAO,CAAC,aAAa,cAAc,YAAY,EAAE,aAAa,cAAc,UAAU,CAAC;IACxF,CAAC;AACF,kBAAe,KAAK,IAAI,GAAG,cAAc,QAAQ,SAAS,aAAa;;AAIzE,MAAI,eAAe,KAAK,QAAQ,SAAS,aAEvC,WADgB,QAAQ,MAAM,CAAC,aAAa,GACxB;MAGpB,WAAU;;AAMhB,KAAI,SAAS;EACX,MAAM,QAAQ,aAAa,QAAQ,SAAS,aAAa;EACzD,MAAM,cAAc,SAAS,IAAI,QAAQ;EACzC,MAAM,YAAY,SAAS,IAAI,QAAQ,QAAQ,SAAS,aAAa;AACrE,SAAO,KAAK;GACV,MAAM;GACN,OAAO,OAAO;GACd,OAAO,CAAC,aAAa,UAAU;GAC/B,OAAO,CAAC,aAAa,cAAc,YAAY,EAAE,aAAa,cAAc,UAAU,CAAC;GACxF,CAAC;;AAGJ,QAAO"}