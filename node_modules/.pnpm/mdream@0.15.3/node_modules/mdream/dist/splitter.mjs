import { $ as TAG_H2, F as TAG_CODE, Nt as TAG_PRE, Q as TAG_H1, et as TAG_H3, gn as TEXT_NODE, h as NodeEventExit, m as NodeEventEnter, nt as TAG_H5, ot as TAG_HR, r as ELEMENT_NODE, rt as TAG_H6, tt as TAG_H4 } from "./_chunks/const.mjs";
import { a as parseHtmlStream, n as createMarkdownProcessor, r as processPluginsForEvent } from "./_chunks/markdown-processor.mjs";

//#region src/splitter.ts
const DEFAULT_HEADERS_TO_SPLIT_ON = [
	TAG_H2,
	TAG_H3,
	TAG_H4,
	TAG_H5,
	TAG_H6
];
function createOptions(options) {
	return {
		headersToSplitOn: options.headersToSplitOn ?? DEFAULT_HEADERS_TO_SPLIT_ON,
		returnEachLine: options.returnEachLine ?? false,
		stripHeaders: options.stripHeaders ?? true,
		chunkSize: options.chunkSize ?? 1e3,
		chunkOverlap: options.chunkOverlap ?? 200,
		lengthFunction: options.lengthFunction ?? ((text) => text.length),
		keepSeparator: options.keepSeparator ?? false,
		origin: options.origin,
		plugins: options.plugins ?? []
	};
}
function getCodeLanguage(node) {
	const className = node.attributes?.class;
	if (!className) return "";
	const langParts = className.split(" ").map((c) => c.split("language-")[1]).filter(Boolean);
	return langParts.length > 0 ? langParts[0].trim() : "";
}
function shouldSplitOnHeader(tagId, options) {
	return options.headersToSplitOn.includes(tagId);
}
/**
* Get current markdown content WITHOUT clearing buffers
*/
function getCurrentMarkdown(state) {
	const fragments = [];
	for (const [regionId, content] of state.regionContentBuffers.entries()) if (state.regionToggles.get(regionId)) fragments.push(...content);
	return fragments.join("").trimStart();
}
/**
* Convert HTML to Markdown and split into chunks in single pass
* Yields chunks during HTML event processing for better memory efficiency
*/
function* htmlToMarkdownSplitChunksStream(html, options = {}) {
	const opts = createOptions(options);
	if (opts.chunkOverlap >= opts.chunkSize) throw new Error("chunkOverlap must be less than chunkSize");
	const processor = createMarkdownProcessor({
		origin: opts.origin,
		plugins: opts.plugins
	});
	const headerHierarchy = /* @__PURE__ */ new Map();
	const seenSplitHeaders = /* @__PURE__ */ new Set();
	let currentChunkCodeLanguage = "";
	let collectingHeaderText = false;
	let currentHeaderTagId = null;
	let currentHeaderText = "";
	let lineNumber = 1;
	let lastChunkEndPosition = 0;
	let lastSplitPosition = 0;
	function* flushChunk(endPosition, applyOverlap = false) {
		const currentMd = getCurrentMarkdown(processor.state);
		const chunkEnd = endPosition ?? currentMd.length;
		const originalChunkContent = currentMd.slice(lastChunkEndPosition, chunkEnd);
		if (!originalChunkContent.trim()) {
			lastChunkEndPosition = chunkEnd;
			return;
		}
		let chunkContent = originalChunkContent;
		if (opts.stripHeaders) {
			chunkContent = chunkContent.split("\n").filter((line) => !line.match(/^#{1,6}\s+/)).join("\n").trim();
			if (!chunkContent) {
				lastChunkEndPosition = chunkEnd;
				return;
			}
		}
		const chunk = {
			content: chunkContent.trimEnd(),
			metadata: { loc: { lines: {
				from: lineNumber,
				to: lineNumber + (originalChunkContent.match(/\n/g) || []).length
			} } }
		};
		if (headerHierarchy.size > 0) {
			chunk.metadata.headers = {};
			for (const [tagId, text] of headerHierarchy.entries()) {
				const level = `h${tagId - TAG_H1 + 1}`;
				chunk.metadata.headers[level] = text;
			}
		}
		if (currentChunkCodeLanguage) chunk.metadata.code = currentChunkCodeLanguage;
		yield chunk;
		currentChunkCodeLanguage = "";
		lastSplitPosition = chunkEnd;
		if (applyOverlap && opts.chunkOverlap > 0) {
			const maxOverlap = Math.max(0, originalChunkContent.length - 1);
			lastChunkEndPosition = chunkEnd - Math.min(opts.chunkOverlap, maxOverlap);
		} else lastChunkEndPosition = chunkEnd;
		lineNumber += (originalChunkContent.match(/\n/g) || []).length;
	}
	const parseState = {
		depthMap: processor.state.depthMap,
		depth: 0,
		plugins: opts.plugins
	};
	const eventBuffer = [];
	parseHtmlStream(html, parseState, (event) => {
		eventBuffer.push(event);
	});
	for (const event of eventBuffer) {
		const { type: eventType, node } = event;
		if (node.type === ELEMENT_NODE) {
			const element = node;
			const tagId = element.tagId;
			if (tagId && tagId >= TAG_H1 && tagId <= TAG_H6) {
				if (eventType === NodeEventEnter) {
					collectingHeaderText = true;
					currentHeaderTagId = tagId;
					currentHeaderText = "";
					if (shouldSplitOnHeader(tagId, opts)) {
						if (seenSplitHeaders.has(tagId)) {
							yield* flushChunk();
							for (let i = tagId; i <= TAG_H6; i++) headerHierarchy.delete(i);
						}
						seenSplitHeaders.add(tagId);
					}
				} else if (eventType === NodeEventExit && currentHeaderTagId === tagId) {
					headerHierarchy.set(tagId, currentHeaderText.trim());
					collectingHeaderText = false;
					currentHeaderTagId = null;
				}
			}
			if (tagId === TAG_CODE && element.depthMap[TAG_PRE] > 0) {
				if (eventType === NodeEventEnter) {
					const lang = getCodeLanguage(element);
					if (lang && !currentChunkCodeLanguage) currentChunkCodeLanguage = lang;
				}
			}
			if (tagId === TAG_HR && eventType === NodeEventEnter) yield* flushChunk();
		}
		if (collectingHeaderText && node.type === TEXT_NODE) currentHeaderText += node.value;
		processPluginsForEvent(event, opts.plugins, processor.state, processor.processEvent);
		if (!opts.returnEachLine) {
			const currentMd = getCurrentMarkdown(processor.state);
			if (opts.lengthFunction(currentMd.slice(lastChunkEndPosition)) > opts.chunkSize) {
				const idealSplitPos = lastChunkEndPosition + opts.chunkSize;
				const separators = [
					"\n\n",
					"```\n",
					"\n",
					" "
				];
				let splitPosition = -1;
				for (const sep of separators) {
					const idx = currentMd.lastIndexOf(sep, idealSplitPos);
					const candidateSplitPos = idx + sep.length;
					if (idx >= 0) {
						const beforeSplit = currentMd.slice(0, candidateSplitPos);
						let backtickCount = 0;
						let pos = 0;
						while ((pos = beforeSplit.indexOf("```", pos)) !== -1) {
							backtickCount++;
							pos += 3;
						}
						if (backtickCount % 2 === 1) continue;
					}
					if (idx >= 0 && candidateSplitPos > lastSplitPosition) {
						splitPosition = candidateSplitPos;
						break;
					}
				}
				if (splitPosition === -1 || splitPosition <= lastChunkEndPosition) splitPosition = currentMd.length;
				yield* flushChunk(splitPosition, true);
			}
		}
	}
	yield* flushChunk();
}
/**
* Convert HTML to Markdown and split into chunks in single pass
* Chunks are created during HTML event processing
*/
function htmlToMarkdownSplitChunks(html, options = {}) {
	const opts = createOptions(options);
	const chunks = [];
	for (const chunk of htmlToMarkdownSplitChunksStream(html, options)) chunks.push(chunk);
	if (opts.returnEachLine && chunks.length > 0) {
		const lineChunks = [];
		for (const chunk of chunks) {
			const lines = chunk.content.split("\n");
			const chunkStartLine = chunk.metadata.loc?.lines.from || 1;
			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];
				if (line.trim()) lineChunks.push({
					content: line,
					metadata: {
						...chunk.metadata,
						loc: { lines: {
							from: chunkStartLine + i,
							to: chunkStartLine + i
						} }
					}
				});
			}
		}
		return lineChunks;
	}
	return chunks;
}

//#endregion
export { htmlToMarkdownSplitChunks, htmlToMarkdownSplitChunksStream };