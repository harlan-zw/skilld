import "./_chunks/markdown-processor.mjs";
import { n as streamHtmlToMarkdown } from "./_chunks/src.mjs";
import { n as generateLlmsTxtArtifacts } from "./_chunks/llms-txt.mjs";
import "./_chunks/plugins.mjs";
import { t as withMinimalPreset } from "./_chunks/minimal.mjs";
import { readFileSync } from "node:fs";
import { mkdir, writeFile } from "node:fs/promises";
import { Readable } from "node:stream";
import { fileURLToPath } from "node:url";
import { cac } from "cac";
import { dirname, join, resolve } from "pathe";

//#region src/cli.ts
async function streamingConvert(options = {}) {
	const outputStream = process.stdout;
	let conversionOptions = { origin: options.origin };
	if (options.preset === "minimal") conversionOptions = withMinimalPreset(conversionOptions);
	const markdownGenerator = streamHtmlToMarkdown(Readable.toWeb(process.stdin), conversionOptions);
	for await (const markdownChunk of markdownGenerator) if (markdownChunk && markdownChunk.length > 0) outputStream.write(markdownChunk);
}
async function generateLlms(patterns, options) {
	try {
		const artifacts = options.artifacts ? options.artifacts.split(",").map((a) => a.trim()) : [
			"llms.txt",
			"llms-full.txt",
			"markdown"
		];
		const outputDir = resolve(options.output);
		const result = await generateLlmsTxtArtifacts({
			patterns,
			siteName: options.siteName,
			description: options.description,
			origin: options.origin,
			generateFull: artifacts.includes("llms-full.txt"),
			generateMarkdown: artifacts.includes("markdown")
		});
		await mkdir(outputDir, { recursive: true });
		await writeFile(join(outputDir, "llms.txt"), result.llmsTxt, "utf-8");
		if (artifacts.includes("llms-full.txt") && result.llmsFullTxt) await writeFile(join(outputDir, "llms-full.txt"), result.llmsFullTxt, "utf-8");
		if (artifacts.includes("markdown") && result.markdownFiles) for (const mdFile of result.markdownFiles) {
			const fullPath = join(outputDir, mdFile.path);
			await mkdir(dirname(fullPath), { recursive: true });
			await writeFile(fullPath, mdFile.content, "utf-8");
		}
		console.log(`✅ Generated llms.txt artifacts in: ${outputDir}`);
	} catch (error) {
		console.error("❌ Error generating llms.txt:", error);
		process.exit(1);
	}
}
const packageJsonPath = join(dirname(fileURLToPath(import.meta.url)), "..", "package.json");
const version = JSON.parse(readFileSync(packageJsonPath, "utf-8")).version;
const cli = cac();
cli.command("[options]", "Convert HTML from stdin to Markdown on stdout").option("--origin <url>", "Origin URL for resolving relative image paths").option("--preset <preset>", "Conversion presets: minimal").action(async (_, opts) => {
	await streamingConvert(opts);
});
cli.command("llms <patterns...>", "Generate llms.txt artifacts from HTML files").option("--site-name <name>", "Name of the site for llms.txt header").option("--description <desc>", "Description of the site for llms.txt").option("--origin <url>", "Origin URL for resolving relative paths and generating absolute URLs").option("-o, --output <dir>", "Output directory for generated files", { default: process.cwd() }).option("--artifacts <list>", "Comma-separated list of artifacts to generate: llms.txt,llms-full.txt,markdown", { default: "llms.txt,llms-full.txt,markdown" }).action(async (patterns, opts) => {
	await generateLlms(patterns, {
		patterns,
		...opts
	});
});
cli.help().version(version).parse();

//#endregion
export {  };