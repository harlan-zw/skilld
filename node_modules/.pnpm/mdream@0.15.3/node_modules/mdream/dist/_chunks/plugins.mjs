import { $ as TAG_H2, $t as TAG_TBODY, A as TAG_BUTTON, At as TAG_P, Bt as TAG_SCRIPT, C as TAG_AUDIO, D as TAG_BLOCKQUOTE, Dt as TAG_OBJECT, F as TAG_CODE, G as TAG_EM, Gt as TAG_SPAN, H as TAG_DIV, Ht as TAG_SELECT, J as TAG_FIGCAPTION, K as TAG_EMBED, Kt as TAG_STRONG, L as TAG_DD, M as TAG_CAPTION, Nt as TAG_PRE, O as TAG_BODY, Ot as TAG_OL, Q as TAG_H1, Qt as TAG_TABLE, S as TAG_ASIDE, St as TAG_META, U as TAG_DL, Vt as TAG_SECTION, W as TAG_DT, X as TAG_FOOTER, Y as TAG_FIGURE, Yt as TAG_SUMMARY, Z as TAG_FORM, Zt as TAG_SVG, _ as TAG_A, _t as TAG_LI, an as TAG_THEAD, at as TAG_HEADER, bn as createBufferRegion, cn as TAG_TR, ct as TAG_I, dn as TAG_UL, dt as TAG_INPUT, en as TAG_TD, et as TAG_H3, gn as TEXT_NODE, in as TAG_TH, it as TAG_HEAD, k as TAG_BR, lt as TAG_IFRAME, nn as TAG_TEXTAREA, nt as TAG_H5, ot as TAG_HR, pn as TAG_VIDEO, q as TAG_FIELDSET, qt as TAG_STYLE, r as ELEMENT_NODE, rn as TAG_TFOOT, rt as TAG_H6, sn as TAG_TITLE, st as TAG_HTML, tt as TAG_H4, ut as TAG_IMG, w as TAG_B, wt as TAG_NAV, x as TAG_ARTICLE, y as TAG_ADDRESS, yn as collectNodeContent, yt as TAG_MAIN, z as TAG_DETAILS } from "./const.mjs";
import { t as createPlugin } from "./plugin.mjs";
import { n as parseSelector } from "./extraction.mjs";

//#region src/plugins/filter.ts
/**
* Plugin that filters nodes based on CSS selectors.
* Allows including or excluding nodes based on selectors.
*
* @example
* // Include only heading elements and their children
* withQuerySelectorPlugin({ include: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] })
*
* @example
* // Exclude navigation, sidebar, and footer
* withQuerySelectorPlugin({ exclude: ['nav', '#sidebar', '.footer'] })
*/
function filterPlugin(options = {}) {
	const includeSelectors = options.include?.map((selector) => {
		if (typeof selector === "string") return parseSelector(selector);
		return { matches: (element) => element.tagId === selector };
	}) || [];
	const excludeSelectors = options.exclude?.map((selector) => {
		if (typeof selector === "string") return parseSelector(selector);
		return { matches: (element) => element.tagId === selector };
	}) || [];
	const processChildren = options.processChildren !== false;
	return createPlugin({ beforeNodeProcess(event) {
		const { node } = event;
		if (node.type === TEXT_NODE) {
			let currentParent$1 = node.parent;
			while (currentParent$1 && excludeSelectors.length) {
				if (excludeSelectors.some((selector) => selector.matches(currentParent$1))) return { skip: true };
				currentParent$1 = currentParent$1.parent;
			}
			return;
		}
		if (node.type !== ELEMENT_NODE) return;
		const element = node;
		if (excludeSelectors.length) {
			if (element.attributes.style?.includes("absolute") || element.attributes.style?.includes("fixed")) return { skip: true };
			if (excludeSelectors.some((selector) => selector.matches(element))) return { skip: true };
		}
		let currentParent = element.parent;
		while (currentParent) {
			if (excludeSelectors.length) {
				if (excludeSelectors.some((selector) => selector.matches(currentParent))) return { skip: true };
			}
			currentParent = currentParent.parent;
		}
		if (includeSelectors.length) {
			let currentElement = element;
			while (currentElement) {
				if (includeSelectors.some((selector) => selector.matches(currentElement))) return;
				if (!processChildren) break;
				currentElement = currentElement.parent;
			}
			return { skip: true };
		}
	} });
}

//#endregion
//#region src/plugins/frontmatter.ts
/**
* A plugin that manages frontmatter generation from HTML head elements
* Extracts metadata from meta tags and title and generates YAML frontmatter
*/
function frontmatterPlugin(options = {}) {
	const additionalFields = options.additionalFields || {};
	const metaFields = new Set([
		"description",
		"keywords",
		"author",
		"date",
		"og:title",
		"og:description",
		"twitter:title",
		"twitter:description",
		...options.metaFields || []
	]);
	const frontmatter = {
		...additionalFields,
		meta: {}
	};
	let inHead = false;
	const formatValue = options.formatValue || ((name, value) => {
		value = value.replace(/"/g, "\\\"");
		if (value.includes("\n") || value.includes(":") || value.includes("#") || value.includes(" ")) return `"${value}"`;
		return value;
	});
	return createPlugin({
		onNodeEnter(node) {
			if (node.tagId === TAG_HEAD) {
				inHead = true;
				return;
			}
			if (inHead && node.type === ELEMENT_NODE && node.tagId === TAG_TITLE) return;
			if (inHead && node.type === ELEMENT_NODE && node.tagId === TAG_META) {
				const { name, property, content } = node.attributes || {};
				const metaName = property || name;
				if (metaName && content && metaFields.has(metaName)) frontmatter.meta[metaName.includes(":") ? `"${metaName}"` : metaName] = formatValue(metaName, content);
				return;
			}
		},
		onNodeExit(node, state) {
			if (node.type === ELEMENT_NODE && node.tagId === TAG_HEAD) {
				inHead = false;
				if (Object.keys(frontmatter).length > 0) collectNodeContent({
					type: 1,
					regionId: 0
				}, generateFrontmatter(), state);
			}
		},
		processTextNode(node) {
			if (!inHead) return;
			const parent = node.parent;
			if (parent && parent.tagId === TAG_TITLE && node.value) {
				frontmatter.title = formatValue("title", node.value.trim());
				return {
					content: "",
					skip: true
				};
			}
		}
	});
	/**
	* Generate YAML frontmatter string from collected metadata
	*/
	function generateFrontmatter() {
		if (Object.keys(frontmatter).length === 0) return "";
		let yamlLines = [];
		const entries = Object.entries(frontmatter).sort(([a], [b]) => {
			if (a === "title") return -1;
			if (b === "title") return 1;
			if (a === "description") return -1;
			if (b === "description") return 1;
			return a.localeCompare(b);
		});
		for (const [key, value] of entries) if (key === "meta" && typeof value === "object" && value && Object.keys(value).length > 0) {
			yamlLines.push("meta:");
			const metaEntries = Object.entries(value).sort(([a], [b]) => a.localeCompare(b)).map(([metaKey, metaValue]) => `  ${metaKey}: ${metaValue}`);
			yamlLines.push(...metaEntries);
		} else if (key !== "meta" && typeof value === "string") yamlLines.push(`${key}: ${value}`);
		if (Object.keys(frontmatter.meta).length === 0) yamlLines = yamlLines.filter((line) => !line.startsWith("meta:"));
		return `---\n${yamlLines.join("\n")}\n---\n\n`;
	}
}

//#endregion
//#region src/plugins/isolate-main.ts
/**
* Plugin that isolates main content using the following priority order:
* 1. If an explicit <main> element exists (within 5 depth levels), use its content exclusively
* 2. Otherwise, find content between the first header tag (h1-h6) and first footer
* 3. If footer is within 5 levels of nesting from the header, use it as the end boundary
* 4. Exclude all content before the start marker and after the end marker
*
* @example
* ```html
* <body>
*   <nav>Navigation (excluded)</nav>
*   <main>
*     <h1>Main Title (included)</h1>
*     <p>Main content (included)</p>
*   </main>
*   <footer>Footer (excluded)</footer>
* </body>
* ```
*
* @example
* ```html
* <body>
*   <nav>Navigation (excluded)</nav>
*   <h1>Main Title (included)</h1>
*   <p>Main content (included)</p>
*   <footer>Footer (excluded)</footer>
* </body>
* ```
*/
function isolateMainPlugin() {
	let mainElement = null;
	let firstHeaderElement = null;
	let afterFooter = false;
	const headerTagIds = new Set([
		TAG_H1,
		TAG_H2,
		TAG_H3,
		TAG_H4,
		TAG_H5,
		TAG_H6
	]);
	return createPlugin({ beforeNodeProcess(event) {
		const { node } = event;
		if (node.type === ELEMENT_NODE) {
			const element = node;
			if (!mainElement && element.tagId === TAG_MAIN && element.depth <= 5) {
				mainElement = element;
				return;
			}
			if (mainElement) {
				let current = element.parent;
				let isInsideMain = element === mainElement;
				while (current && !isInsideMain) {
					if (current === mainElement) {
						isInsideMain = true;
						break;
					}
					current = current.parent;
				}
				if (!isInsideMain) return { skip: true };
				return;
			}
			if (!firstHeaderElement && element.tagId !== void 0 && headerTagIds.has(element.tagId)) {
				let current = element.parent;
				let isInHeaderTag = false;
				while (current) {
					if (current.tagId === TAG_HEADER) {
						isInHeaderTag = true;
						break;
					}
					current = current.parent;
				}
				if (!isInHeaderTag) {
					firstHeaderElement = element;
					return;
				}
			}
			if (firstHeaderElement && !afterFooter && element.tagId === TAG_FOOTER) {
				if (element.depth - firstHeaderElement.depth <= 5) {
					afterFooter = true;
					return { skip: true };
				}
			}
			if (!firstHeaderElement) {
				if (element.tagId === TAG_HEAD) return;
				let current = element.parent;
				while (current) {
					if (current.tagId === TAG_HEAD) return;
					current = current.parent;
				}
				return { skip: true };
			}
			if (afterFooter) return { skip: true };
		}
		if (node.type === TEXT_NODE) {
			if (mainElement) {
				let current = node.parent;
				let isInsideMain = false;
				while (current) {
					if (current === mainElement) {
						isInsideMain = true;
						break;
					}
					current = current.parent;
				}
				if (!isInsideMain) return { skip: true };
				return;
			}
			if (!firstHeaderElement || afterFooter) {
				let current = node.parent;
				while (current) {
					if (current.tagId === TAG_HEAD) return;
					current = current.parent;
				}
				return { skip: true };
			}
		}
	} });
}

//#endregion
//#region src/plugins/readability.ts
const REGEXPS = {
	positive: /article|body|content|entry|main|page|post|text|blog|story|recipe|ingredient|instruction|description|docs?|guide|tutorial|reference|manual/i,
	negative: /ad|banner|combx|comment|disqus|extra|foot|header|menu|meta|nav|promo|related|scroll|share|sidebar|sponsor|social|tags|widget|sitemap|copyright|login|register|subscribe|newsletter|signup|category|author|date|publish|cta|button|apply|trial|likes|views|metrics|stats|breadcrumb|pagination|filter|sort|search/i,
	commas: /,/g,
	periodAtEnd: /\.( |$)/,
	hidden: /hidden|display:\s*none|visibility:\s*hidden/i,
	advertisement: /^ad-|^ad$|advertisement|sponsor|promo|banner/i,
	comments: /comment|disqus|replies/i
};
const TagScores = {
	[TAG_ARTICLE]: 15,
	[TAG_SECTION]: 8,
	[TAG_MAIN]: 15,
	[TAG_P]: 5,
	[TAG_DIV]: 2,
	[TAG_BLOCKQUOTE]: 5,
	[TAG_PRE]: 8,
	[TAG_CODE]: 6,
	[TAG_IMG]: 3,
	[TAG_FIGURE]: 4,
	[TAG_FIGCAPTION]: 3,
	[TAG_VIDEO]: 3,
	[TAG_AUDIO]: 3,
	[TAG_SVG]: 1,
	[TAG_TABLE]: 0,
	[TAG_CAPTION]: 2,
	[TAG_THEAD]: 0,
	[TAG_TBODY]: 0,
	[TAG_TFOOT]: 0,
	[TAG_TR]: -1,
	[TAG_TH]: -2,
	[TAG_TD]: 0,
	[TAG_UL]: -8,
	[TAG_OL]: -5,
	[TAG_LI]: -6,
	[TAG_DL]: 0,
	[TAG_DT]: 0,
	[TAG_DD]: 0,
	[TAG_H1]: 1,
	[TAG_H2]: 1,
	[TAG_H3]: 1,
	[TAG_H4]: 0,
	[TAG_H5]: 0,
	[TAG_H6]: 0,
	[TAG_HEADER]: -15,
	[TAG_FOOTER]: -25,
	[TAG_NAV]: -30,
	[TAG_ASIDE]: -25,
	[TAG_FORM]: -8,
	[TAG_BUTTON]: -5,
	[TAG_INPUT]: -5,
	[TAG_TEXTAREA]: -5,
	[TAG_SELECT]: -5,
	[TAG_FIELDSET]: -5,
	[TAG_IFRAME]: -3,
	[TAG_EMBED]: -3,
	[TAG_OBJECT]: -3,
	[TAG_A]: -8,
	[TAG_STRONG]: 1,
	[TAG_B]: 1,
	[TAG_EM]: 1,
	[TAG_I]: 1,
	[TAG_HR]: 0,
	[TAG_BR]: 0,
	[TAG_SPAN]: 0,
	[TAG_SCRIPT]: -25,
	[TAG_STYLE]: -25,
	[TAG_DETAILS]: 2,
	[TAG_SUMMARY]: 1,
	[TAG_ADDRESS]: -3
};
/**
* Apply score adjustments based on class and ID names
*/
function scoreClassAndId(node) {
	let scoreAdjustment = 0;
	if (node.attributes?.class) {
		const className = node.attributes.class;
		if (/nav|menu|header|footer|sidebar|ad-|advertisement|banner|promo|cta|button|apply|trial|engagement|sharing|likes|views|metrics|stats|breadcrumb|pagination|filter|sort|search/i.test(className)) scoreAdjustment -= 35;
		else if (REGEXPS.negative.test(className)) scoreAdjustment -= 15;
		else if (REGEXPS.positive.test(className)) {
			scoreAdjustment += 10;
			if (/docs?|guide|tutorial|reference|manual|article/i.test(className)) scoreAdjustment += 5;
		}
	}
	if (node.attributes?.id) {
		const id = node.attributes.id;
		if (/nav|menu|header|footer|sidebar|ad-|advertisement|banner|promo|cta|button|apply|trial|engagement|sharing|likes|views|metrics|stats|breadcrumb|pagination|filter|sort|search/i.test(id)) scoreAdjustment -= 35;
		else if (REGEXPS.negative.test(id)) scoreAdjustment -= 15;
		else if (REGEXPS.positive.test(id)) {
			scoreAdjustment += 10;
			if (/docs?|guide|tutorial|reference|manual|article/i.test(id)) scoreAdjustment += 5;
		}
	}
	return scoreAdjustment;
}
/**
* Creates a plugin that implements readability.js style heuristics for content quality assessment
* Controls content inclusion/exclusion using buffer regions
*/
function readabilityPlugin() {
	let inHead = false;
	return createPlugin({
		onNodeEnter(node, state) {
			if (inHead) return;
			if (!node.context) node.context = {};
			if (node.tagId === TAG_BODY || node.tagId === TAG_HTML) return;
			if (node.tagId === TAG_HEAD) {
				createBufferRegion(node, state, true);
				inHead = true;
				return;
			}
			const tagScore = node.tagId !== void 0 ? TagScores[node.tagId] ?? 0 : 0;
			const classAndIdScore = scoreClassAndId(node);
			node.context.score = tagScore + classAndIdScore;
			node.context.tagCount = 1;
			node.context.linkTextLength = 0;
			node.context.textLength = 0;
			if (node.name && /nav|header|footer|aside|form|fieldset|button/i.test(node.name) || node.attributes?.class && /nav|menu|header|footer|sidebar|hidden|copyright|ad-|advertisement|banner|promo|related|comment|login|register|subscribe|newsletter|category|meta|tag|cta|button|apply|trial|engagement|sharing|likes|views|metrics|stats|breadcrumb|pagination|filter|sort|search/i.test(node.attributes.class) || node.attributes?.id && /nav|menu|header|footer|sidebar|hidden|copyright|ad-|advertisement|banner|promo|related|comment|login|register|subscribe|newsletter|category|meta|tag|cta|button|apply|trial|engagement|sharing|likes|views|metrics|stats|breadcrumb|pagination|filter|sort|search/i.test(node.attributes.id) || node.attributes?.style && /display:\s*none|visibility:\s*hidden/i.test(node.attributes.style) || node.attributes && Object.keys(node.attributes).some((attr) => attr.startsWith("aria-") && node.attributes[attr] === "true" && /hidden|invisible/i.test(attr))) createBufferRegion(node, state, false);
			else if (node.parent && node.parent.context) node.context.score = (node.context.score || 0) + (node.parent.context.score || 0);
		},
		processTextNode(node) {
			if (!node.parent || inHead) return void 0;
			const textValue = node.value;
			const len = textValue.length;
			const commaCount = Math.min(3, (textValue.match(REGEXPS.commas) || []).length);
			const isInsideLink = !!node.parent.depthMap?.[TAG_A];
			let parent = node.parent;
			while (parent) {
				if (!parent.context) parent.context = {};
				parent.context.score = (parent.context.score || 0) + commaCount;
				parent.context.textLength = (parent.context.textLength || 0) + len;
				if (isInsideLink) parent.context.linkTextLength = (parent.context.linkTextLength || 0) + len;
				parent = parent.parent;
			}
		},
		onNodeExit(node, state) {
			if (!node.context) return;
			if (node.tagId === TAG_BODY || node.tagId === TAG_HTML) return;
			if (node.tagId === TAG_HEAD) {
				inHead = false;
				return;
			}
			if (inHead) return;
			const textLength = node.context.textLength || 0;
			if (textLength === 0 && node.tagId !== TAG_BODY && !node.childTextNodeIndex) {} else if (textLength > 100) node.context.score = (node.context.score || 0) + 3;
			else if (textLength >= 50) node.context.score = (node.context.score || 0) + 2;
			else if (textLength >= 25) node.context.score = (node.context.score || 0) + 1;
			const linkTextLength = node.context.linkTextLength || 0;
			if (textLength > 0) {
				const linkDensity = linkTextLength / textLength;
				if (linkDensity > .4) if (linkDensity > .6) {
					node.context.score = (node.context.score || 0) * .02;
					if (linkTextLength > 50) node.context.isHighLinkDensity = true;
				} else node.context.score = (node.context.score || 0) * (1 - linkDensity * 2);
				else if (linkDensity > .2) node.context.score = (node.context.score || 0) * (1 - linkDensity * 1);
			}
			if (linkTextLength > 0 && textLength > 0) {
				const linkRatio = linkTextLength / textLength;
				const hasDocumentationMarkers = node.attributes?.class && /docs?|guide|tutorial|reference|manual|article|content/i.test(node.attributes.class) || node.attributes?.id && /docs?|guide|tutorial|reference|manual|article|content/i.test(node.attributes.id) || node.name && /main|article|section/i.test(node.name);
				if (linkRatio > .3 && linkTextLength > 30 && !hasDocumentationMarkers) node.context.score = (node.context.score || 0) - 10;
			}
			const finalScore = node.context.score || 0;
			if (finalScore <= -12) createBufferRegion(node, state, false);
			else if (node.context.isHighLinkDensity || linkTextLength > 50 && textLength > 0 && linkTextLength / textLength > .5) createBufferRegion(node, state, false);
			if (node.tagHandler?.isInline) {
				const parent = node.parent;
				if (parent && parent.context) parent.context.score = (parent.context.score || 0) + finalScore;
			}
		}
	});
}

//#endregion
//#region src/plugins/tailwind.ts
/**
* Mapping of Tailwind classes to Markdown formatting
*/
const TAILWIND_TO_MARKDOWN_MAP = {
	"font-bold": {
		prefix: "**",
		suffix: "**"
	},
	"font-semibold": {
		prefix: "**",
		suffix: "**"
	},
	"font-black": {
		prefix: "**",
		suffix: "**"
	},
	"font-extrabold": {
		prefix: "**",
		suffix: "**"
	},
	"font-medium": {
		prefix: "**",
		suffix: "**"
	},
	"font-italic": {
		prefix: "*",
		suffix: "*"
	},
	"italic": {
		prefix: "*",
		suffix: "*"
	},
	"line-through": {
		prefix: "~~",
		suffix: "~~"
	},
	"hidden": { hidden: true },
	"invisible": { hidden: true },
	"absolute": { hidden: true },
	"fixed": { hidden: true },
	"sticky": { hidden: true }
};
/**
* Extract base class name from a responsive breakpoint variant
*/
function extractBaseClass(className) {
	for (const bp of [
		"sm:",
		"md:",
		"lg:",
		"xl:",
		"2xl:"
	]) if (className.startsWith(bp)) return {
		baseClass: className.substring(bp.length),
		breakpoint: bp
	};
	return {
		baseClass: className,
		breakpoint: ""
	};
}
/**
* Sort classes by breakpoint for mobile-first processing
*/
function sortByBreakpoint(classes) {
	const breakpointOrder = {
		"": 0,
		"sm:": 1,
		"md:": 2,
		"lg:": 3,
		"xl:": 4,
		"2xl:": 5
	};
	return [...classes].sort((a, b) => {
		const aBreakpoint = extractBaseClass(a).breakpoint;
		const bBreakpoint = extractBaseClass(b).breakpoint;
		return breakpointOrder[aBreakpoint] - breakpointOrder[bBreakpoint];
	});
}
/**
* Group classes by their formatting type to handle overrides
*/
function groupByFormattingType(classes) {
	const sorted = sortByBreakpoint(classes);
	const groups = {
		emphasis: [],
		weight: [],
		decoration: [],
		display: [],
		position: [],
		other: []
	};
	for (const cls of sorted) {
		const { baseClass } = extractBaseClass(cls);
		if (baseClass.includes("italic")) groups.emphasis.push(cls);
		else if (baseClass.includes("font-") || baseClass === "bold") groups.weight.push(cls);
		else if (baseClass.includes("line-through") || baseClass.includes("underline")) groups.decoration.push(cls);
		else if (baseClass === "hidden" || baseClass.includes("invisible")) groups.display.push(cls);
		else if ([
			"absolute",
			"fixed",
			"sticky"
		].includes(baseClass)) groups.position.push(cls);
		else groups.other.push(cls);
	}
	return groups;
}
/**
* Fix redundant markdown delimiters without regex
*/
function fixRedundantDelimiters(content) {
	content = content.replaceAll("****", "**");
	content = content.replaceAll("~~~~", "~~");
	if (content.includes("***") && content.split("***").length > 3) {
		const parts = content.split("***");
		if (parts.length >= 4) content = `${parts[0]}***${parts[1]} ${parts[2]}***${parts.slice(3).join("***")}`;
	}
	return content;
}
/**
* Normalizes a list of Tailwind classes by processing breakpoints and resolving conflicts
*/
function normalizeClasses(classes) {
	const result = [];
	const mobileClasses = classes.filter((cls) => !hasBreakpoint(cls));
	const breakpointClasses = classes.filter((cls) => hasBreakpoint(cls));
	result.push(...mobileClasses);
	result.push(...breakpointClasses);
	return result;
}
/**
* Check if a class has a breakpoint prefix
*/
function hasBreakpoint(className) {
	const { breakpoint } = extractBaseClass(className);
	return breakpoint !== "";
}
/**
* Process Tailwind classes for an element with mobile-first approach
*/
function processTailwindClasses(classes) {
	let prefix = "";
	let suffix = "";
	let hidden = false;
	const grouped = groupByFormattingType(normalizeClasses(classes));
	if (grouped.weight.length > 0) {
		const { baseClass } = extractBaseClass(grouped.weight[0]);
		const mapping = TAILWIND_TO_MARKDOWN_MAP[baseClass];
		if (mapping) {
			if (mapping.prefix) prefix += mapping.prefix;
			if (mapping.suffix) suffix = mapping.suffix + suffix;
		}
	}
	if (grouped.emphasis.length > 0) {
		const { baseClass } = extractBaseClass(grouped.emphasis[0]);
		const mapping = TAILWIND_TO_MARKDOWN_MAP[baseClass];
		if (mapping) {
			if (mapping.prefix) prefix += mapping.prefix;
			if (mapping.suffix) suffix = mapping.suffix + suffix;
		}
	}
	if (grouped.decoration.length > 0) {
		const { baseClass } = extractBaseClass(grouped.decoration[0]);
		const mapping = TAILWIND_TO_MARKDOWN_MAP[baseClass];
		if (mapping) {
			if (mapping.prefix) prefix += mapping.prefix;
			if (mapping.suffix) suffix = mapping.suffix + suffix;
		}
	}
	for (const cls of grouped.display) {
		const { baseClass } = extractBaseClass(cls);
		const mapping = TAILWIND_TO_MARKDOWN_MAP[baseClass];
		if (mapping && mapping.hidden) {
			hidden = true;
			break;
		}
	}
	for (const cls of grouped.position) {
		const { baseClass } = extractBaseClass(cls);
		const mapping = TAILWIND_TO_MARKDOWN_MAP[baseClass];
		if (mapping && mapping.hidden) {
			hidden = true;
			break;
		}
	}
	return {
		prefix,
		suffix,
		hidden
	};
}
/**
* Creates a plugin that adds Tailwind class processing
*/
function tailwindPlugin() {
	return createPlugin({
		processAttributes(node) {
			const classAttr = node.attributes?.class;
			if (!classAttr) return;
			const { prefix, suffix, hidden } = processTailwindClasses(classAttr.trim().split(" ").filter(Boolean));
			node.context = node.context || {};
			node.context.tailwind = {
				prefix,
				suffix,
				hidden
			};
		},
		processTextNode(node) {
			const parentNode = node.parent;
			if (!parentNode || parentNode.type !== ELEMENT_NODE) return;
			const tailwindData = parentNode.context?.tailwind;
			if (tailwindData?.hidden) return {
				content: "",
				skip: true
			};
			let content = node.value;
			const prefix = tailwindData?.prefix || "";
			const suffix = tailwindData?.suffix || "";
			if (prefix || suffix) {
				content = prefix + content + suffix;
				content = fixRedundantDelimiters(content);
			}
			return {
				content,
				skip: false
			};
		},
		beforeNodeProcess({ node }) {
			if (node.type === ELEMENT_NODE) {
				if ((node.context?.tailwind)?.hidden) return { skip: true };
			}
		}
	});
}

//#endregion
export { filterPlugin as a, frontmatterPlugin as i, readabilityPlugin as n, isolateMainPlugin as r, tailwindPlugin as t };