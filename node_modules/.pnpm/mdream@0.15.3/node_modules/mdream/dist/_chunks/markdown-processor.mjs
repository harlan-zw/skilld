import { $ as TAG_H2, $t as TAG_TBODY, A as TAG_BUTTON, At as TAG_P, B as TAG_DFN, Bt as TAG_SCRIPT, C as TAG_AUDIO, Ct as TAG_METER, D as TAG_BLOCKQUOTE, E as TAG_BDO, Et as TAG_NOSCRIPT, F as TAG_CODE, Ft as TAG_Q, G as TAG_EM, Gt as TAG_SPAN, H as TAG_DIV, Ht as TAG_SELECT, I as TAG_COL, It as TAG_RP, Jt as TAG_SUB, K as TAG_EMBED, Kt as TAG_STRONG, L as TAG_DD, Lt as TAG_RT, Mt as TAG_PLAINTEXT, N as TAG_CENTER, Nt as TAG_PRE, O as TAG_BODY, Ot as TAG_OL, P as TAG_CITE, Pt as TAG_PROGRESS, Q as TAG_H1, Qt as TAG_TABLE, R as TAG_DEL, Rt as TAG_RUBY, S as TAG_ASIDE, St as TAG_META, T as TAG_BASE, Tt as TAG_NOFRAMES, U as TAG_DL, Ut as TAG_SMALL, V as TAG_DIALOG, W as TAG_DT, Wt as TAG_SOURCE, X as TAG_FOOTER, Xt as TAG_SUP, Yt as TAG_SUMMARY, Z as TAG_FORM, Zt as TAG_SVG, _ as TAG_A, _n as TagIdMap, _t as TAG_LI, a as LIST_ITEM_SPACING, an as TAG_THEAD, b as TAG_AREA, bt as TAG_MAP, c as MARKDOWN_HORIZONTAL_RULE, cn as TAG_TR, ct as TAG_I, d as MARKDOWN_STRONG, dn as TAG_UL, dt as TAG_INPUT, en as TAG_TD, et as TAG_H3, f as MAX_TAG_ID, fn as TAG_VAR, ft as TAG_INS, g as TABLE_ROW_SPACING, gn as TEXT_NODE, gt as TAG_LEGEND, h as NodeEventExit, hn as TAG_XMP, ht as TAG_LABEL, i as HTML_ENTITIES, in as TAG_TH, it as TAG_HEAD, j as TAG_CANVAS, jt as TAG_PARAM, k as TAG_BR, kt as TAG_OPTION, l as MARKDOWN_INLINE_CODE, ln as TAG_TRACK, lt as TAG_IFRAME, m as NodeEventEnter, mn as TAG_WBR, mt as TAG_KEYGEN, n as DEFAULT_BLOCK_SPACING, nn as TAG_TEXTAREA, nt as TAG_H5, o as MARKDOWN_CODE_BLOCK, on as TAG_TIME, ot as TAG_HR, p as NO_SPACING, pn as TAG_VIDEO, pt as TAG_KBD, q as TAG_FIELDSET, qt as TAG_STYLE, r as ELEMENT_NODE, rn as TAG_TFOOT, rt as TAG_H6, s as MARKDOWN_EMPHASIS, sn as TAG_TITLE, t as BLOCKQUOTE_SPACING, tn as TAG_TEMPLATE, tt as TAG_H4, u as MARKDOWN_STRIKETHROUGH, un as TAG_U, ut as TAG_IMG, v as TAG_ABBR, vn as assembleBufferedContent, vt as TAG_LINK, w as TAG_B, wt as TAG_NAV, xt as TAG_MARK, y as TAG_ADDRESS, yn as collectNodeContent, z as TAG_DETAILS, zt as TAG_SAMP } from "./const.mjs";

//#region src/tags.ts
function resolveUrl(url, origin) {
	if (!url) return url;
	if (url.startsWith("//")) return `https:${url}`;
	if (url.startsWith("#")) return url;
	if (origin) {
		if (url.startsWith("/") && origin) return `${origin.endsWith("/") ? origin.slice(0, -1) : origin}${url}`;
		if (url.startsWith("./")) return `${origin}/${url.slice(2)}`;
		if (!url.startsWith("http")) return `${origin}/${url.startsWith("/") ? url.slice(1) : url}`;
	}
	return url;
}
function isInsideTableCell(node) {
	return node.depthMap[TAG_TD] > 0;
}
function getLanguageFromClass(className) {
	if (!className) return "";
	const langParts = className.split(" ").map((c) => c.split("language-")[1]).filter(Boolean);
	return langParts.length > 0 ? langParts[0].trim() : "";
}
function handleHeading(depth) {
	return {
		enter: ({ node }) => {
			if (node.depthMap[TAG_A]) return `<h${depth}>`;
			return `${"#".repeat(depth)} `;
		},
		exit: ({ node }) => {
			if (node.depthMap[TAG_A]) return `</h${depth}>`;
		},
		collapsesInnerWhiteSpace: true
	};
}
const Strong = {
	enter: ({ node }) => {
		if (node.depthMap[TAG_B] > 1) return "";
		return MARKDOWN_STRONG;
	},
	exit: ({ node }) => {
		if (node.depthMap[TAG_B] > 1) return "";
		return MARKDOWN_STRONG;
	},
	collapsesInnerWhiteSpace: true,
	spacing: NO_SPACING,
	isInline: true
};
const Emphasis = {
	enter: ({ node }) => {
		if (node.depthMap[TAG_I] > 1) return "";
		return MARKDOWN_EMPHASIS;
	},
	exit: ({ node }) => {
		if (node.depthMap[TAG_I] > 1) return "";
		return MARKDOWN_EMPHASIS;
	},
	collapsesInnerWhiteSpace: true,
	spacing: NO_SPACING,
	isInline: true
};
const tagHandlers = {
	[TAG_HEAD]: {
		spacing: NO_SPACING,
		collapsesInnerWhiteSpace: true
	},
	[TAG_DETAILS]: {
		enter: () => "<details>",
		exit: () => "</details>\n\n"
	},
	[TAG_SUMMARY]: {
		enter: () => "<summary>",
		exit: () => "</summary>\n\n"
	},
	[TAG_TITLE]: {
		collapsesInnerWhiteSpace: true,
		isNonNesting: true,
		spacing: NO_SPACING
	},
	[TAG_SCRIPT]: {
		excludesTextNodes: true,
		isNonNesting: true
	},
	[TAG_STYLE]: {
		isNonNesting: true,
		excludesTextNodes: true
	},
	[TAG_META]: {
		collapsesInnerWhiteSpace: true,
		isSelfClosing: true,
		spacing: NO_SPACING
	},
	[TAG_BR]: {
		enter: ({ node }) => {
			return isInsideTableCell(node) ? "<br>" : void 0;
		},
		isSelfClosing: true,
		spacing: NO_SPACING,
		collapsesInnerWhiteSpace: true,
		isInline: true
	},
	[TAG_H1]: handleHeading(1),
	[TAG_H2]: handleHeading(2),
	[TAG_H3]: handleHeading(3),
	[TAG_H4]: handleHeading(4),
	[TAG_H5]: handleHeading(5),
	[TAG_H6]: handleHeading(6),
	[TAG_HR]: {
		enter: () => MARKDOWN_HORIZONTAL_RULE,
		isSelfClosing: true
	},
	[TAG_STRONG]: Strong,
	[TAG_B]: Strong,
	[TAG_EM]: Emphasis,
	[TAG_I]: Emphasis,
	[TAG_DEL]: {
		enter: () => MARKDOWN_STRIKETHROUGH,
		exit: () => MARKDOWN_STRIKETHROUGH,
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_SUB]: {
		enter: () => "<sub>",
		exit: () => "</sub>",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_SUP]: {
		enter: () => "<sup>",
		exit: () => "</sup>",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_INS]: {
		enter: () => "<ins>",
		exit: () => "</ins>",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_BLOCKQUOTE]: {
		enter: ({ node }) => {
			const depth = node.depthMap[TAG_BLOCKQUOTE] || 1;
			let prefix = "> ".repeat(depth);
			if (node.depthMap[TAG_LI] > 0) prefix = `\n${"  ".repeat(node.depthMap[TAG_LI])}${prefix}`;
			return prefix;
		},
		spacing: BLOCKQUOTE_SPACING
	},
	[TAG_CODE]: {
		enter: ({ node }) => {
			if ((node.depthMap[TAG_PRE] || 0) > 0) return `${MARKDOWN_CODE_BLOCK}${getLanguageFromClass(node.attributes?.class)}\n`;
			return MARKDOWN_INLINE_CODE;
		},
		exit: ({ node }) => {
			return node.depthMap[TAG_PRE] > 0 ? `\n${MARKDOWN_CODE_BLOCK}` : MARKDOWN_INLINE_CODE;
		},
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_UL]: {
		enter: ({ node }) => isInsideTableCell(node) ? "<ul>" : void 0,
		exit: ({ node }) => isInsideTableCell(node) ? "</ul>" : void 0
	},
	[TAG_LI]: {
		enter: ({ node }) => {
			if (isInsideTableCell(node)) return "<li>";
			const depth = (node.depthMap[TAG_UL] || 0) + (node.depthMap[TAG_OL] || 0) - 1;
			const isOrdered = node.parent?.tagId === TAG_OL;
			return `${"  ".repeat(Math.max(0, depth))}${isOrdered ? `${node.index + 1}. ` : "- "}`;
		},
		exit: ({ node }) => isInsideTableCell(node) ? "</li>" : void 0,
		spacing: LIST_ITEM_SPACING
	},
	[TAG_A]: {
		enter: ({ node }) => {
			if (node.attributes?.href) return "[";
		},
		exit: ({ node, state }) => {
			if (!node.attributes?.href) return "";
			const href = resolveUrl(node.attributes?.href || "", state.options?.origin);
			let title = node.attributes?.title;
			if (state.lastContentCache === title) title = "";
			return title ? `](${href} "${title}")` : `](${href})`;
		},
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_IMG]: {
		enter: ({ node, state }) => {
			return `![${node.attributes?.alt || ""}](${resolveUrl(node.attributes?.src || "", state.options?.origin)})`;
		},
		collapsesInnerWhiteSpace: true,
		isSelfClosing: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_TABLE]: {
		enter: ({ node, state }) => {
			if (isInsideTableCell(node)) return "<table>";
			if (node.depthMap[TAG_TABLE] <= 1) state.tableRenderedTable = false;
			state.tableColumnAlignments = [];
		},
		exit: ({ node }) => isInsideTableCell(node) ? "</table>" : void 0
	},
	[TAG_THEAD]: {
		enter: ({ node }) => {
			if (isInsideTableCell(node)) return "<thead>";
		},
		exit: ({ node }) => isInsideTableCell(node) ? "</thead>" : void 0,
		spacing: TABLE_ROW_SPACING,
		excludesTextNodes: true
	},
	[TAG_TR]: {
		enter: ({ node, state }) => {
			if (isInsideTableCell(node)) return "<tr>";
			state.tableCurrentRowCells = 0;
			return "| ";
		},
		exit: ({ node, state }) => {
			if (isInsideTableCell(node) || node.depthMap[TAG_TABLE] > 1) return "</tr>";
			if (!state.tableRenderedTable) {
				state.tableRenderedTable = true;
				const alignments = state.tableColumnAlignments;
				while (alignments.length < state.tableCurrentRowCells) alignments.push("");
				return ` |\n| ${alignments.map((align) => {
					switch (align) {
						case "left": return ":---";
						case "center": return ":---:";
						case "right": return "---:";
						default: return "---";
					}
				}).join(" | ")} |`;
			}
			return " |";
		},
		excludesTextNodes: true,
		spacing: TABLE_ROW_SPACING
	},
	[TAG_TH]: {
		enter: ({ node, state }) => {
			if (node.depthMap[TAG_TABLE] > 1) return "<th>";
			const align = node.attributes?.align?.toLowerCase();
			if (align) state.tableColumnAlignments.push(align);
			else if (state.tableColumnAlignments.length <= state.tableCurrentRowCells) state.tableColumnAlignments.push("");
			return node.index === 0 ? "" : " | ";
		},
		exit: ({ node, state }) => {
			if (node.depthMap[TAG_TABLE] > 1) return "</th>";
			state.tableCurrentRowCells++;
		},
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING
	},
	[TAG_TD]: {
		enter: ({ node }) => {
			if (node.depthMap[TAG_TABLE] > 1) return "<td>";
			return node.index === 0 ? "" : " | ";
		},
		exit: ({ node, state }) => {
			if (node.depthMap[TAG_TABLE] > 1) return "</td>";
			state.tableCurrentRowCells++;
		},
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING
	},
	[TAG_P]: {},
	[TAG_DIV]: {},
	[TAG_SPAN]: {
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_NAV]: {},
	[TAG_LABEL]: {
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_BUTTON]: {
		collapsesInnerWhiteSpace: true,
		isInline: true
	},
	[TAG_BODY]: { spacing: NO_SPACING },
	[TAG_CENTER]: {
		enter: ({ node }) => {
			if (node.depthMap[TAG_TABLE] > 1) return "<center>";
		},
		exit: ({ node }) => {
			if (node.depthMap[TAG_TABLE] > 1) return "</center>";
		},
		spacing: NO_SPACING
	},
	[TAG_TBODY]: {
		spacing: NO_SPACING,
		excludesTextNodes: true
	},
	[TAG_TFOOT]: {
		spacing: TABLE_ROW_SPACING,
		excludesTextNodes: true
	},
	[TAG_KBD]: {
		enter: () => "`",
		exit: () => "`",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_FOOTER]: { spacing: NO_SPACING },
	[TAG_FORM]: { spacing: NO_SPACING },
	[TAG_LINK]: {
		isSelfClosing: true,
		spacing: NO_SPACING,
		collapsesInnerWhiteSpace: true,
		isInline: true
	},
	[TAG_AREA]: {
		isSelfClosing: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_BASE]: {
		isSelfClosing: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_COL]: {
		isSelfClosing: true,
		spacing: NO_SPACING
	},
	[TAG_EMBED]: {
		isSelfClosing: true,
		spacing: NO_SPACING
	},
	[TAG_INPUT]: {
		isSelfClosing: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_KEYGEN]: {
		isSelfClosing: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_PARAM]: {
		isSelfClosing: true,
		spacing: NO_SPACING
	},
	[TAG_SOURCE]: {
		isSelfClosing: true,
		spacing: NO_SPACING
	},
	[TAG_TRACK]: {
		isSelfClosing: true,
		spacing: NO_SPACING
	},
	[TAG_WBR]: {
		isSelfClosing: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_SVG]: { spacing: NO_SPACING },
	[TAG_SELECT]: { spacing: NO_SPACING },
	[TAG_TEXTAREA]: {
		isNonNesting: true,
		spacing: NO_SPACING
	},
	[TAG_OPTION]: {
		isNonNesting: true,
		spacing: NO_SPACING
	},
	[TAG_FIELDSET]: { spacing: NO_SPACING },
	[TAG_LEGEND]: { spacing: NO_SPACING },
	[TAG_AUDIO]: { spacing: NO_SPACING },
	[TAG_VIDEO]: { spacing: NO_SPACING },
	[TAG_CANVAS]: { spacing: NO_SPACING },
	[TAG_IFRAME]: {
		isNonNesting: true,
		spacing: NO_SPACING
	},
	[TAG_MAP]: { spacing: NO_SPACING },
	[TAG_DIALOG]: { spacing: NO_SPACING },
	[TAG_METER]: { spacing: NO_SPACING },
	[TAG_PROGRESS]: { spacing: NO_SPACING },
	[TAG_TEMPLATE]: { spacing: NO_SPACING },
	[TAG_ABBR]: {
		enter: () => "",
		exit: () => "",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_MARK]: {
		enter: () => "<mark>",
		exit: () => "</mark>",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_Q]: {
		enter: () => "\"",
		exit: () => "\"",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_SAMP]: {
		enter: () => "`",
		exit: () => "`",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_SMALL]: {
		enter: () => "",
		exit: () => "",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_NOSCRIPT]: {
		excludesTextNodes: true,
		spacing: NO_SPACING
	},
	[TAG_NOFRAMES]: {
		isNonNesting: true,
		spacing: NO_SPACING
	},
	[TAG_XMP]: {
		isNonNesting: true,
		spacing: NO_SPACING
	},
	[TAG_PLAINTEXT]: {
		isNonNesting: true,
		spacing: NO_SPACING
	},
	[TAG_ASIDE]: { spacing: NO_SPACING },
	[TAG_U]: {
		enter: () => {
			return "<u>";
		},
		exit: () => {
			return "</u>";
		},
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_CITE]: {
		enter: () => "*",
		exit: () => "*",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_DFN]: {
		enter: () => "**",
		exit: () => "**",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_VAR]: {
		enter: () => "`",
		exit: () => "`",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_TIME]: {
		enter: () => "",
		exit: () => "",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_BDO]: {
		enter: () => "",
		exit: () => "",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_RUBY]: {
		enter: () => "",
		exit: () => "",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_RT]: {
		enter: () => "",
		exit: () => "",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_RP]: {
		enter: () => "",
		exit: () => "",
		collapsesInnerWhiteSpace: true,
		spacing: NO_SPACING,
		isInline: true
	},
	[TAG_ADDRESS]: {
		enter: () => "<address>",
		exit: () => "</address>",
		spacing: NO_SPACING,
		collapsesInnerWhiteSpace: true
	},
	[TAG_DL]: {
		spacing: NO_SPACING,
		enter: () => "<dl>",
		exit: () => "</dl>"
	},
	[TAG_DT]: {
		enter: () => "<dt>",
		exit: () => "</dt>",
		collapsesInnerWhiteSpace: true,
		spacing: [0, 1]
	},
	[TAG_DD]: {
		enter: () => "<dd>",
		exit: () => "</dd>",
		spacing: [0, 1]
	}
};

//#endregion
//#region src/utils.ts
/**
* Decode HTML entities - optimized version with single pass
*/
function decodeHTMLEntities(text) {
	let result = "";
	let i = 0;
	while (i < text.length) {
		if (text[i] === "&") {
			let match = false;
			for (const [entity, replacement] of Object.entries(HTML_ENTITIES)) if (text.startsWith(entity, i)) {
				result += replacement;
				i += entity.length;
				match = true;
				break;
			}
			if (match) continue;
			if (i + 2 < text.length && text[i + 1] === "#") {
				const start = i;
				i += 2;
				const isHex = text[i] === "x" || text[i] === "X";
				if (isHex) i++;
				const numStart = i;
				while (i < text.length && text[i] !== ";") i++;
				if (i < text.length && text[i] === ";") {
					const numStr = text.substring(numStart, i);
					const base = isHex ? 16 : 10;
					try {
						const codePoint = Number.parseInt(numStr, base);
						if (!Number.isNaN(codePoint)) {
							result += String.fromCodePoint(codePoint);
							i++;
							continue;
						}
					} catch {}
				}
				i = start;
			}
		}
		result += text[i];
		i++;
	}
	return result;
}
function traverseUpToFirstBlockNode(node) {
	let firstBlockParent = node;
	const parentsToIncrement = [firstBlockParent];
	while (firstBlockParent.tagHandler?.isInline) {
		if (!firstBlockParent.parent) break;
		firstBlockParent = firstBlockParent.parent;
		parentsToIncrement.push(firstBlockParent);
	}
	return parentsToIncrement;
}

//#endregion
//#region src/parse.ts
const LT_CHAR = 60;
const GT_CHAR = 62;
const SLASH_CHAR = 47;
const EQUALS_CHAR = 61;
const QUOTE_CHAR = 34;
const APOS_CHAR = 39;
const EXCLAMATION_CHAR = 33;
const AMPERSAND_CHAR = 38;
const BACKSLASH_CHAR = 92;
const DASH_CHAR = 45;
const SPACE_CHAR = 32;
const TAB_CHAR = 9;
const NEWLINE_CHAR = 10;
const CARRIAGE_RETURN_CHAR = 13;
const BACKTICK_CHAR = 96;
const PIPE_CHAR = 124;
const OPEN_BRACKET_CHAR = 91;
const CLOSE_BRACKET_CHAR = 93;
const EMPTY_ATTRIBUTES = Object.freeze({});
function copyDepthMap(depthMap) {
	return new Uint8Array(depthMap);
}
/**
* Fast whitespace check using direct character code comparison
*/
function isWhitespace(charCode) {
	return charCode === SPACE_CHAR || charCode === TAB_CHAR || charCode === NEWLINE_CHAR || charCode === CARRIAGE_RETURN_CHAR;
}
/**
* Pure HTML parser that emits DOM events
* Completely decoupled from markdown generation
*/
function parseHtml(html, options = {}) {
	const events = [];
	return {
		events,
		remainingHtml: parseHtmlInternal(html, {
			depthMap: new Uint8Array(MAX_TAG_ID),
			depth: 0,
			plugins: options.plugins || []
		}, (event) => {
			events.push(event);
		})
	};
}
/**
* Streaming HTML parser - calls onEvent for each DOM event
*/
function parseHtmlStream(html, state, onEvent) {
	return parseHtmlInternal(html, state, onEvent);
}
/**
* Internal parsing function - extracted from original parseHTML
*/
function parseHtmlInternal(htmlChunk, state, handleEvent) {
	let textBuffer = "";
	state.depthMap ??= new Uint8Array(MAX_TAG_ID);
	state.depth ??= 0;
	state.lastCharWasWhitespace ??= true;
	state.justClosedTag ??= false;
	state.isFirstTextInElement ??= false;
	state.lastCharWasBackslash ??= false;
	let i = 0;
	const chunkLength = htmlChunk.length;
	while (i < chunkLength) {
		const currentCharCode = htmlChunk.charCodeAt(i);
		if (currentCharCode !== LT_CHAR) {
			if (currentCharCode === AMPERSAND_CHAR) state.hasEncodedHtmlEntity = true;
			if (isWhitespace(currentCharCode)) {
				const inPreTag = state.depthMap[TAG_PRE] > 0;
				if (state.justClosedTag) {
					state.justClosedTag = false;
					state.lastCharWasWhitespace = false;
				}
				if (!inPreTag && state.lastCharWasWhitespace) {
					i++;
					continue;
				}
				if (inPreTag) textBuffer += htmlChunk[i];
				else if (currentCharCode === SPACE_CHAR || !state.lastCharWasWhitespace) textBuffer += " ";
				state.lastCharWasWhitespace = true;
				state.textBufferContainsWhitespace = true;
				state.lastCharWasBackslash = false;
			} else {
				state.textBufferContainsNonWhitespace = true;
				state.lastCharWasWhitespace = false;
				state.justClosedTag = false;
				if (currentCharCode === PIPE_CHAR && state.depthMap[TAG_TABLE]) textBuffer += "\\|";
				else if (currentCharCode === BACKTICK_CHAR && (state.depthMap[TAG_CODE] || state.depthMap[TAG_PRE])) textBuffer += "\\`";
				else if (currentCharCode === OPEN_BRACKET_CHAR && state.depthMap[TAG_A]) textBuffer += "\\[";
				else if (currentCharCode === CLOSE_BRACKET_CHAR && state.depthMap[TAG_A]) textBuffer += "\\]";
				else if (currentCharCode === GT_CHAR && state.depthMap[TAG_BLOCKQUOTE]) textBuffer += "\\>";
				else textBuffer += htmlChunk[i];
				if (state.currentNode?.tagHandler?.isNonNesting) {
					if (!state.lastCharWasBackslash) {
						if (currentCharCode === APOS_CHAR && !state.inDoubleQuote && !state.inBacktick) state.inSingleQuote = !state.inSingleQuote;
						else if (currentCharCode === QUOTE_CHAR && !state.inSingleQuote && !state.inBacktick) state.inDoubleQuote = !state.inDoubleQuote;
						else if (currentCharCode === BACKTICK_CHAR && !state.inSingleQuote && !state.inDoubleQuote) state.inBacktick = !state.inBacktick;
					}
				}
				state.lastCharWasBackslash = currentCharCode === BACKSLASH_CHAR;
			}
			i++;
			continue;
		}
		if (i + 1 >= chunkLength) {
			textBuffer += htmlChunk[i];
			break;
		}
		const nextCharCode = htmlChunk.charCodeAt(i + 1);
		if (nextCharCode === EXCLAMATION_CHAR) {
			if (textBuffer.length > 0) {
				processTextBuffer(textBuffer, state, handleEvent);
				textBuffer = "";
			}
			const result = processCommentOrDoctype(htmlChunk, i);
			if (result.complete) i = result.newPosition;
			else {
				textBuffer += result.remainingText;
				break;
			}
		} else if (nextCharCode === SLASH_CHAR) {
			const inQuotes = state.inSingleQuote || state.inDoubleQuote || state.inBacktick;
			if (state.currentNode?.tagHandler?.isNonNesting && inQuotes) {
				textBuffer += htmlChunk[i];
				i++;
				continue;
			}
			if (textBuffer.length > 0) {
				processTextBuffer(textBuffer, state, handleEvent);
				textBuffer = "";
			}
			const result = processClosingTag(htmlChunk, i, state, handleEvent);
			if (result.complete) i = result.newPosition;
			else {
				textBuffer += result.remainingText;
				break;
			}
		} else {
			let i2 = i + 1;
			const tagNameStart = i2;
			let tagNameEnd = -1;
			while (i2 < chunkLength) {
				const c = htmlChunk.charCodeAt(i2);
				if (isWhitespace(c) || c === SLASH_CHAR || c === GT_CHAR) {
					tagNameEnd = i2;
					break;
				}
				i2++;
			}
			if (tagNameEnd === -1) {
				textBuffer += htmlChunk.substring(i);
				break;
			}
			const tagName = htmlChunk.substring(tagNameStart, tagNameEnd).toLowerCase();
			if (!tagName) {
				i = tagNameEnd;
				break;
			}
			const tagId = TagIdMap[tagName] ?? -1;
			i2 = tagNameEnd;
			if (state.currentNode?.tagHandler?.isNonNesting) {
				if (tagId !== state.currentNode?.tagId) {
					textBuffer += htmlChunk[i++];
					continue;
				}
			}
			if (textBuffer.length > 0) {
				processTextBuffer(textBuffer, state, handleEvent);
				textBuffer = "";
			}
			const result = processOpeningTag(tagName, tagId, htmlChunk, i2, state, handleEvent);
			if (result.skip) textBuffer += htmlChunk[i++];
			else if (result.complete) {
				i = result.newPosition;
				if (!result.selfClosing) state.isFirstTextInElement = true;
			} else {
				textBuffer += result.remainingText;
				break;
			}
		}
	}
	return textBuffer;
}
/**
* Process accumulated text buffer and create text node event
*/
function processTextBuffer(textBuffer, state, handleEvent) {
	const containsNonWhitespace = state.textBufferContainsNonWhitespace;
	const containsWhitespace = state.textBufferContainsWhitespace;
	state.textBufferContainsNonWhitespace = false;
	state.textBufferContainsWhitespace = false;
	if (!state.currentNode) return;
	const excludesTextNodes = state.currentNode?.tagHandler?.excludesTextNodes;
	const inPreTag = state.depthMap[TAG_PRE] > 0;
	if (!inPreTag && !containsNonWhitespace && !state.currentNode.childTextNodeIndex) return;
	let text = textBuffer;
	if (text.length === 0) return;
	const parentsToIncrement = traverseUpToFirstBlockNode(state.currentNode);
	const firstBlockParent = parentsToIncrement[parentsToIncrement.length - 1];
	if (containsWhitespace && !firstBlockParent?.childTextNodeIndex) {
		let start = 0;
		while (start < text.length && (inPreTag ? text.charCodeAt(start) === NEWLINE_CHAR || text.charCodeAt(start) === CARRIAGE_RETURN_CHAR : isWhitespace(text.charCodeAt(start)))) start++;
		if (start > 0) text = text.substring(start);
	}
	if (state.hasEncodedHtmlEntity) {
		text = decodeHTMLEntities(String(text));
		state.hasEncodedHtmlEntity = false;
	}
	const textNode = {
		type: TEXT_NODE,
		value: text,
		parent: state.currentNode,
		regionId: state.currentNode?.regionId,
		index: state.currentNode.currentWalkIndex++,
		depth: state.depth,
		containsWhitespace,
		excludedFromMarkdown: excludesTextNodes
	};
	for (const parent of parentsToIncrement) parent.childTextNodeIndex = (parent.childTextNodeIndex || 0) + 1;
	handleEvent({
		type: NodeEventEnter,
		node: textNode
	});
	state.lastTextNode = textNode;
}
/**
* Process HTML closing tag
*/
function processClosingTag(htmlChunk, position, state, handleEvent) {
	let i = position + 2;
	const tagNameStart = i;
	const chunkLength = htmlChunk.length;
	let foundClose = false;
	while (i < chunkLength) {
		if (htmlChunk.charCodeAt(i) === GT_CHAR) {
			foundClose = true;
			break;
		}
		i++;
	}
	if (!foundClose) return {
		complete: false,
		newPosition: position,
		remainingText: htmlChunk.substring(position)
	};
	const tagId = TagIdMap[htmlChunk.substring(tagNameStart, i).toLowerCase()] ?? -1;
	if (state.currentNode?.tagHandler?.isNonNesting && tagId !== state.currentNode.tagId) return {
		complete: false,
		newPosition: position,
		remainingText: htmlChunk.substring(position)
	};
	let curr = state.currentNode;
	if (curr) {
		let match = curr.tagId !== tagId;
		while (curr && match) {
			closeNode(curr, state, handleEvent);
			curr = curr.parent;
			match = curr?.tagId !== tagId;
		}
	}
	if (curr) closeNode(curr, state, handleEvent);
	state.justClosedTag = true;
	return {
		complete: true,
		newPosition: i + 1,
		remainingText: ""
	};
}
/**
* Close a node and emit exit event
*/
function closeNode(node, state, handleEvent) {
	if (!node) return;
	if (node.tagId === TAG_A && !node.childTextNodeIndex) {
		const prefix = node.attributes?.title || node.attributes?.["aria-label"] || "";
		if (prefix) {
			node.childTextNodeIndex = 1;
			handleEvent({
				type: NodeEventEnter,
				node: {
					type: TEXT_NODE,
					value: prefix,
					parent: node,
					index: 0,
					depth: node.depth + 1
				}
			});
			for (const parent of traverseUpToFirstBlockNode(node)) parent.childTextNodeIndex = (parent.childTextNodeIndex || 0) + 1;
		}
	}
	if (node.tagId) state.depthMap[node.tagId] = Math.max(0, state.depthMap[node.tagId] - 1);
	if (node.tagHandler?.isNonNesting) {
		state.inSingleQuote = false;
		state.inDoubleQuote = false;
		state.inBacktick = false;
		state.lastCharWasBackslash = false;
	}
	state.depth--;
	handleEvent({
		type: NodeEventExit,
		node
	});
	state.currentNode = state.currentNode.parent;
	state.hasEncodedHtmlEntity = false;
	state.justClosedTag = true;
}
/**
* Process HTML comment or doctype
*/
function processCommentOrDoctype(htmlChunk, position) {
	let i = position;
	const chunkLength = htmlChunk.length;
	if (i + 3 < chunkLength && htmlChunk.charCodeAt(i + 2) === DASH_CHAR && htmlChunk.charCodeAt(i + 3) === DASH_CHAR) {
		i += 4;
		while (i < chunkLength - 2) {
			if (htmlChunk.charCodeAt(i) === DASH_CHAR && htmlChunk.charCodeAt(i + 1) === DASH_CHAR && htmlChunk.charCodeAt(i + 2) === GT_CHAR) {
				i += 3;
				return {
					complete: true,
					newPosition: i,
					remainingText: ""
				};
			}
			i++;
		}
		return {
			complete: false,
			newPosition: position,
			remainingText: htmlChunk.substring(position)
		};
	} else {
		i += 2;
		while (i < chunkLength) {
			if (htmlChunk.charCodeAt(i) === GT_CHAR) {
				i++;
				return {
					complete: true,
					newPosition: i,
					remainingText: ""
				};
			}
			i++;
		}
		return {
			complete: false,
			newPosition: i,
			remainingText: htmlChunk.substring(position, i)
		};
	}
}
/**
* Process HTML opening tag
*/
function processOpeningTag(tagName, tagId, htmlChunk, i, state, handleEvent) {
	if (state.currentNode?.tagHandler?.isNonNesting) closeNode(state.currentNode, state, handleEvent);
	const tagHandler = tagHandlers[tagId];
	const result = processTagAttributes(htmlChunk, i, tagHandler);
	if (!result.complete) return {
		complete: false,
		newPosition: i,
		remainingText: `<${tagName}${result.attrBuffer}`,
		selfClosing: false
	};
	const currentTagCount = state.depthMap[tagId];
	state.depthMap[tagId] = currentTagCount + 1;
	state.depth++;
	i = result.newPosition;
	if (state.currentNode) state.currentNode.currentWalkIndex = state.currentNode.currentWalkIndex || 0;
	const currentWalkIndex = state.currentNode ? state.currentNode.currentWalkIndex++ : 0;
	const tag = {
		type: ELEMENT_NODE,
		name: tagName,
		attributes: result.attributes,
		parent: state.currentNode,
		depthMap: copyDepthMap(state.depthMap),
		depth: state.depth,
		index: currentWalkIndex,
		regionId: state.currentNode?.regionId,
		tagId,
		tagHandler
	};
	state.lastTextNode = tag;
	handleEvent({
		type: NodeEventEnter,
		node: tag
	});
	const parentNode = tag;
	parentNode.currentWalkIndex = 0;
	state.currentNode = parentNode;
	state.hasEncodedHtmlEntity = false;
	if (tagHandler?.isNonNesting && !result.selfClosing) {
		state.inSingleQuote = false;
		state.inDoubleQuote = false;
		state.inBacktick = false;
		state.lastCharWasBackslash = false;
	}
	if (result.selfClosing) {
		closeNode(tag, state, handleEvent);
		state.justClosedTag = true;
	} else state.justClosedTag = false;
	return {
		complete: true,
		newPosition: i,
		remainingText: "",
		selfClosing: result.selfClosing
	};
}
/**
* Extract and process HTML tag attributes
*/
function processTagAttributes(htmlChunk, position, tagHandler) {
	let i = position;
	const chunkLength = htmlChunk.length;
	const selfClosing = tagHandler?.isSelfClosing || false;
	const attrStartPos = i;
	let insideQuote = false;
	let quoteChar = 0;
	let prevChar = 0;
	while (i < chunkLength) {
		const c = htmlChunk.charCodeAt(i);
		if (insideQuote) {
			if (c === quoteChar && prevChar !== BACKSLASH_CHAR) insideQuote = false;
			i++;
			continue;
		} else if (c === QUOTE_CHAR || c === APOS_CHAR) {
			insideQuote = true;
			quoteChar = c;
		} else if (c === SLASH_CHAR && i + 1 < chunkLength && htmlChunk.charCodeAt(i + 1) === GT_CHAR) {
			const attrStr = htmlChunk.substring(attrStartPos, i).trim();
			return {
				complete: true,
				newPosition: i + 2,
				attributes: parseAttributes(attrStr),
				selfClosing: true,
				attrBuffer: attrStr
			};
		} else if (c === GT_CHAR) {
			const attrStr = htmlChunk.substring(attrStartPos, i).trim();
			return {
				complete: true,
				newPosition: i + 1,
				attributes: parseAttributes(attrStr),
				selfClosing,
				attrBuffer: attrStr
			};
		}
		i++;
		prevChar = c;
	}
	return {
		complete: false,
		newPosition: i,
		attributes: EMPTY_ATTRIBUTES,
		selfClosing: false,
		attrBuffer: htmlChunk.substring(attrStartPos, i)
	};
}
/**
* Parse HTML attributes string into key-value object
*/
function parseAttributes(attrStr) {
	if (!attrStr) return EMPTY_ATTRIBUTES;
	const result = {};
	const len = attrStr.length;
	let i = 0;
	const WHITESPACE = 0;
	const NAME = 1;
	const AFTER_NAME = 2;
	const BEFORE_VALUE = 3;
	const QUOTED_VALUE = 4;
	const UNQUOTED_VALUE = 5;
	let state = WHITESPACE;
	let nameStart = 0;
	let nameEnd = 0;
	let valueStart = 0;
	let quoteChar = 0;
	let name = "";
	while (i < len) {
		const charCode = attrStr.charCodeAt(i);
		const isSpace = isWhitespace(charCode);
		switch (state) {
			case WHITESPACE:
				if (!isSpace) {
					state = NAME;
					nameStart = i;
					nameEnd = 0;
				}
				break;
			case NAME:
				if (charCode === EQUALS_CHAR || isSpace) {
					nameEnd = i;
					name = attrStr.substring(nameStart, nameEnd).toLowerCase();
					state = charCode === EQUALS_CHAR ? BEFORE_VALUE : AFTER_NAME;
				}
				break;
			case AFTER_NAME:
				if (charCode === EQUALS_CHAR) state = BEFORE_VALUE;
				else if (!isSpace) {
					result[name] = "";
					state = NAME;
					nameStart = i;
					nameEnd = 0;
				}
				break;
			case BEFORE_VALUE:
				if (charCode === QUOTE_CHAR || charCode === APOS_CHAR) {
					quoteChar = charCode;
					state = QUOTED_VALUE;
					valueStart = i + 1;
				} else if (!isSpace) {
					state = UNQUOTED_VALUE;
					valueStart = i;
				}
				break;
			case QUOTED_VALUE:
				if (charCode === BACKSLASH_CHAR && i + 1 < len) i++;
				else if (charCode === quoteChar) {
					result[name] = attrStr.substring(valueStart, i);
					state = WHITESPACE;
				}
				break;
			case UNQUOTED_VALUE:
				if (isSpace || charCode === GT_CHAR) {
					result[name] = attrStr.substring(valueStart, i);
					state = WHITESPACE;
				}
				break;
		}
		i++;
	}
	if (state === QUOTED_VALUE || state === UNQUOTED_VALUE) {
		if (name) result[name] = attrStr.substring(valueStart, i);
	} else if (state === NAME || state === AFTER_NAME || state === BEFORE_VALUE) {
		nameEnd = nameEnd || i;
		const currentName = attrStr.substring(nameStart, nameEnd).toLowerCase();
		if (currentName) result[currentName] = "";
	}
	return result;
}

//#endregion
//#region src/plugin-processor.ts
/**
* Processes plugins for a given node event
* Shared logic between markdown-processor.ts and stream.ts
*
* @param event - The node event to process
* @param plugins - Array of plugins to apply
* @param state - The current runtime state
* @param processEvent - Callback to process the event after plugin processing
* @returns true if the event should be skipped, false to continue processing
*/
function processPluginsForEvent(event, plugins, state, processEvent) {
	if (plugins?.length) {
		for (const plugin of plugins) {
			const res = plugin.beforeNodeProcess?.(event, state);
			if (typeof res === "object" && res.skip) return true;
		}
		if (event.node.type === ELEMENT_NODE) {
			const element = event.node;
			if (event.type === NodeEventEnter) {
				for (const plugin of plugins) if (plugin.processAttributes) plugin.processAttributes(element, state);
			}
			const fn = event.type === NodeEventEnter ? "onNodeEnter" : "onNodeExit";
			const pluginOutputs = [];
			for (const plugin of plugins) if (plugin[fn]) {
				const result = plugin[fn](element, state);
				if (result) pluginOutputs.push(result);
			}
			if (pluginOutputs.length > 0) element.pluginOutput = (element.pluginOutput || []).concat(pluginOutputs);
		} else if (event.node.type === TEXT_NODE && event.type === NodeEventEnter) {
			const textNode = event.node;
			for (const plugin of plugins) if (plugin.processTextNode) {
				const result = plugin.processTextNode(textNode, state);
				if (result) {
					if (result.skip) return true;
					textNode.value = result.content;
				}
			}
		}
	}
	processEvent(event);
	return false;
}

//#endregion
//#region src/markdown-processor.ts
/**
* Determines if spacing is needed between two characters
*/
function needsSpacing(lastChar, firstChar, state) {
	if (lastChar === " " || lastChar === "\n" || lastChar === "	") return false;
	if (firstChar === " " || firstChar === "\n" || firstChar === "	") return false;
	const noSpaceAfter = new Set([
		"[",
		"(",
		">",
		"*",
		"_",
		"`"
	]);
	const noSpaceBefore = new Set([
		"]",
		")",
		"<",
		".",
		",",
		"!",
		"?",
		":",
		";",
		"*",
		"_",
		"`"
	]);
	if (lastChar === "|" && firstChar === "<" && state && state.depthMap[TAG_TABLE] > 0) return true;
	if (noSpaceAfter.has(lastChar) || noSpaceBefore.has(firstChar)) return false;
	return true;
}
/**
* Determines if spacing should be added before text content
*/
function shouldAddSpacingBeforeText(lastChar, lastNode, textNode) {
	return !!lastChar && lastChar !== "\n" && lastChar !== " " && lastChar !== "[" && lastChar !== ">" && !lastNode?.tagHandler?.isInline && textNode.value[0] !== " ";
}
/**
* Calculate newline configuration based on tag handler spacing config
*/
function calculateNewLineConfig(node) {
	const tagId = node.tagId;
	const depthMap = node.depthMap;
	if (tagId !== TAG_LI && depthMap[TAG_LI] > 0 || tagId !== TAG_BLOCKQUOTE && depthMap[TAG_BLOCKQUOTE] > 0) return NO_SPACING;
	const isBlockElement = tagId !== void 0 && (tagId >= TAG_H1 && tagId <= TAG_H6 || tagId === TAG_P || tagId === TAG_DIV);
	let currParent = node.parent;
	while (currParent) {
		if (currParent.tagHandler?.collapsesInnerWhiteSpace) {
			if (isBlockElement && currParent.tagId === TAG_SPAN) {
				currParent = currParent.parent;
				continue;
			}
			return NO_SPACING;
		}
		currParent = currParent.parent;
	}
	if (node.tagHandler?.spacing) return node.tagHandler?.spacing;
	return DEFAULT_BLOCK_SPACING;
}
/**
* Creates a markdown processor that consumes DOM events and generates markdown
*/
function createMarkdownProcessor(options = {}) {
	const state = {
		options,
		regionToggles: /* @__PURE__ */ new Map(),
		regionContentBuffers: /* @__PURE__ */ new Map(),
		depthMap: new Uint8Array(MAX_TAG_ID)
	};
	state.regionToggles.set(0, true);
	state.regionContentBuffers.set(0, []);
	let lastYieldedLength = 0;
	/**
	* Process a DOM event and generate markdown
	*/
	function processEvent(event) {
		const { type: eventType, node } = event;
		const lastNode = state.lastNode;
		state.lastNode = event.node;
		state.depth = node.depth;
		const buff = state.regionContentBuffers.get(node.regionId || 0) || [];
		const lastBuffEntry = buff[buff.length - 1];
		const lastChar = lastBuffEntry?.charAt(lastBuffEntry.length - 1) || "";
		let secondLastChar;
		if (lastBuffEntry?.length > 1) secondLastChar = lastBuffEntry.charAt(lastBuffEntry.length - 2);
		else secondLastChar = buff[buff.length - 2]?.charAt(buff[buff.length - 2].length - 1);
		if (node.type === TEXT_NODE && eventType === NodeEventEnter) {
			const textNode = node;
			if (textNode.value) {
				if (textNode.excludedFromMarkdown) return;
				if (textNode.value === " " && lastChar === "\n") return;
				if (shouldAddSpacingBeforeText(lastChar, lastNode, textNode)) textNode.value = ` ${textNode.value}`;
				collectNodeContent(textNode, textNode.value, state);
			}
			state.lastTextNode = textNode;
			return;
		}
		if (node.type !== ELEMENT_NODE) return;
		const context = {
			node,
			state
		};
		const output = [];
		const element = node;
		if (element.pluginOutput?.length) {
			output.push(...element.pluginOutput);
			element.pluginOutput = [];
		}
		const lastFragment = state.lastContentCache;
		let lastNewLines = 0;
		if (lastChar === "\n") lastNewLines++;
		if (secondLastChar === "\n") lastNewLines++;
		const eventFn = eventType === NodeEventEnter ? "enter" : "exit";
		const handler = node.tagHandler;
		if (!output.length && handler?.[eventFn]) {
			const res = handler[eventFn](context);
			if (res) output.push(res);
		}
		const configuredNewLines = calculateNewLineConfig(node)[eventType] || 0;
		const newLines = Math.max(0, configuredNewLines - lastNewLines);
		if (newLines > 0) {
			if (!buff.length) {
				for (const fragment of output) collectNodeContent(node, fragment, state);
				return;
			}
			const newlinesStr = "\n".repeat(newLines);
			if (lastChar === " " && buff?.length) buff[buff.length - 1] = buff[buff.length - 1].substring(0, buff[buff.length - 1].length - 1);
			if (eventType === NodeEventEnter) output.unshift(newlinesStr);
			else output.push(newlinesStr);
		} else if (lastFragment && state.lastTextNode?.containsWhitespace && !!node.parent && "value" in state.lastTextNode && typeof state.lastTextNode.value === "string") {
			if (!node.parent.depthMap[TAG_PRE] || node.parent.tagId === TAG_PRE) {
				const isInlineElement = node.tagHandler?.isInline;
				const collapsesWhiteSpace = node.tagHandler?.collapsesInnerWhiteSpace;
				const hasSpacing = node.tagHandler?.spacing && Array.isArray(node.tagHandler.spacing);
				if ((!isInlineElement || eventType === NodeEventExit) && !(!isInlineElement && !collapsesWhiteSpace && configuredNewLines > 0) && !(collapsesWhiteSpace && eventType === NodeEventEnter) && !(hasSpacing && eventType === NodeEventEnter)) {
					const originalLength = lastFragment.length;
					const trimmed = lastFragment.trimEnd();
					if (originalLength - trimmed.length > 0) {
						if (buff?.length && buff[buff.length - 1] === lastFragment) buff[buff.length - 1] = trimmed;
					}
				}
				state.lastTextNode = void 0;
			}
		}
		if (output[0]?.[0] && eventType === NodeEventEnter && lastChar && needsSpacing(lastChar, output[0][0], state)) collectNodeContent(node, " ", state);
		for (const fragment of output) collectNodeContent(node, fragment, state);
	}
	/**
	* Process HTML string and generate events
	*/
	function processHtml(html) {
		parseHtmlStream(html, {
			depthMap: state.depthMap,
			depth: 0,
			plugins: state.options?.plugins || []
		}, (event) => {
			processPluginsForEvent(event, state.options?.plugins, state, processEvent);
		});
	}
	/**
	* Get the final markdown output
	*/
	function getMarkdown() {
		return assembleBufferedContent(state).trimEnd();
	}
	/**
	* Get new markdown content since the last call (for streaming)
	*/
	function getMarkdownChunk() {
		const fragments = [];
		for (const [regionId, content] of Array.from(state.regionContentBuffers.entries())) if (state.regionToggles.get(regionId)) fragments.push(...content);
		const currentContent = fragments.join("").trimStart();
		const newContent = currentContent.slice(lastYieldedLength);
		lastYieldedLength = currentContent.length;
		return newContent;
	}
	return {
		processEvent,
		processHtml,
		getMarkdown,
		getMarkdownChunk,
		state
	};
}
const MarkdownProcessor = createMarkdownProcessor;

//#endregion
export { parseHtmlStream as a, parseHtml as i, createMarkdownProcessor as n, processPluginsForEvent as r, MarkdownProcessor as t };