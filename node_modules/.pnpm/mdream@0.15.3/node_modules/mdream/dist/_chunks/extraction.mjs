import { t as createPlugin } from "./plugin.mjs";

//#region src/libs/query-selector.ts
/**
* Creates a tag selector matcher (e.g., 'div', 'p', 'h1')
*/
function createTagSelector(tagName) {
	return {
		matches: (element) => element.name === tagName,
		toString: () => tagName
	};
}
/**
* Creates an ID selector matcher (e.g., '#main', '#content')
*/
function createIdSelector(selector) {
	const id = selector.slice(1);
	return {
		matches: (element) => element.attributes?.id === id,
		toString: () => `#${id}`
	};
}
/**
* Creates a class selector matcher (e.g., '.container', '.header')
*/
function createClassSelector(selector) {
	const className = selector.slice(1);
	return {
		matches: (element) => {
			if (!element.attributes?.class) return false;
			return element.attributes.class.trim().split(" ").filter(Boolean).includes(className);
		},
		toString: () => `.${className}`
	};
}
/**
* Creates an attribute selector matcher (e.g., '[data-id]', '[href="https://example.com"]')
*/
function createAttributeSelector(selector) {
	const match = selector.match(/\[([^\]=~|^$*]+)(?:([=~|^$*]+)["']?([^"'\]]+)["']?)?\]/);
	const attrName = match ? match[1] : selector.slice(1, -1);
	const operator = match?.[2];
	const attrValue = match?.[3];
	return {
		matches: (element) => {
			if (!(attrName in (element.attributes || {}))) return false;
			if (!operator || !attrValue) return true;
			const value = element.attributes[attrName];
			switch (operator) {
				case "=": return value === attrValue;
				case "^=": return value.startsWith(attrValue);
				case "$=": return value.endsWith(attrValue);
				case "*=": return value.includes(attrValue);
				case "~=": return value.trim().split(" ").filter(Boolean).includes(attrValue);
				case "|=": return value === attrValue || value.startsWith(`${attrValue}-`);
				default: return false;
			}
		},
		toString: () => {
			if (!operator || !attrValue) return `[${attrName}]`;
			return `[${attrName}${operator}${attrValue}]`;
		}
	};
}
/**
* Creates a compound selector that combines multiple selectors (e.g., 'div.container', 'h1#title')
*/
function createCompoundSelector(selectors) {
	return {
		matches: (element) => selectors.every((selector) => selector.matches(element)),
		toString: () => selectors.map((s) => s.toString()).join("")
	};
}
/**
* Parses a CSS selector into a matcher
*/
function parseSelector(selector) {
	selector = selector.trim();
	if (!selector) throw new Error("Empty selector");
	const selectorParts = [];
	let current = "";
	let inAttribute = false;
	for (let i = 0; i < selector.length; i++) {
		const char = selector[i];
		if ((char === "." || char === "#" || char === "[") && current) {
			if (current[0] === ".") selectorParts.push(createClassSelector(current));
			else if (current[0] === "#") selectorParts.push(createIdSelector(current));
			else if (current[0] === "[") selectorParts.push(createAttributeSelector(current));
			else selectorParts.push(createTagSelector(current));
			current = char;
		} else current += char;
		if (char === "[") inAttribute = true;
		if (char === "]") inAttribute = false;
		if (inAttribute && char !== "[") {}
	}
	if (current) if (current[0] === ".") selectorParts.push(createClassSelector(current));
	else if (current[0] === "#") selectorParts.push(createIdSelector(current));
	else if (current[0] === "[") selectorParts.push(createAttributeSelector(current));
	else selectorParts.push(createTagSelector(current));
	if (selectorParts.length === 1) return selectorParts[0];
	return createCompoundSelector(selectorParts);
}

//#endregion
//#region src/plugins/extraction.ts
function extractionPlugin(selectors) {
	const matcherCallbacks = Object.entries(selectors).map(([selector, callback]) => ({
		matcher: parseSelector(selector),
		callback
	}));
	const trackedElements = /* @__PURE__ */ new Map();
	return createPlugin({
		onNodeEnter(element) {
			matcherCallbacks.forEach(({ matcher, callback }) => {
				if (matcher.matches(element)) trackedElements.set(element, {
					textContent: "",
					callback
				});
			});
		},
		processTextNode(textNode) {
			let currentParent = textNode.parent;
			while (currentParent) {
				const tracked = trackedElements.get(currentParent);
				if (tracked) tracked.textContent += textNode.value;
				currentParent = currentParent.parent;
			}
		},
		onNodeExit(element, state) {
			const tracked = trackedElements.get(element);
			if (tracked) {
				const extractedElement = {
					...element,
					textContent: tracked.textContent.trim()
				};
				tracked.callback(extractedElement, state);
				trackedElements.delete(element);
			}
		}
	});
}

//#endregion
export { parseSelector as n, extractionPlugin as t };