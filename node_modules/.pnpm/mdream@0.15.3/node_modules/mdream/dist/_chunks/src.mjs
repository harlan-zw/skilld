import { a as parseHtmlStream, n as createMarkdownProcessor, r as processPluginsForEvent } from "./markdown-processor.mjs";

//#region src/stream.ts
/**
* Creates a markdown stream from an HTML stream
* @param htmlStream - ReadableStream of HTML content (as Uint8Array or string)
* @param options - Configuration options for conversion
* @returns An async generator yielding markdown chunks
*/
async function* streamHtmlToMarkdown(htmlStream, options = {}) {
	if (!htmlStream) throw new Error("Invalid HTML stream provided");
	const decoder = new TextDecoder();
	const reader = htmlStream.getReader();
	const processor = createMarkdownProcessor(options);
	const parseState = {
		depthMap: new Uint8Array(1024),
		depth: 0,
		plugins: options.plugins || []
	};
	let remainingHtml = "";
	try {
		while (true) {
			const { done, value } = await reader.read();
			if (done) break;
			remainingHtml = parseHtmlStream(`${remainingHtml}${typeof value === "string" ? value : decoder.decode(value, { stream: true })}`, parseState, (event) => {
				processPluginsForEvent(event, options.plugins, processor.state, processor.processEvent);
			});
			const chunk = processor.getMarkdownChunk();
			if (chunk) yield chunk;
		}
		if (remainingHtml) parseHtmlStream(remainingHtml, parseState, (event) => {
			processPluginsForEvent(event, options.plugins, processor.state, processor.processEvent);
		});
		const finalChunk = processor.getMarkdownChunk();
		if (finalChunk) yield finalChunk;
	} finally {
		if (remainingHtml) decoder.decode(new Uint8Array(0), { stream: false });
		reader.releaseLock();
	}
}

//#endregion
//#region src/index.ts
function htmlToMarkdown(html, options = {}) {
	const processor = createMarkdownProcessor(options);
	processor.processHtml(html);
	return processor.getMarkdown();
}

//#endregion
export { streamHtmlToMarkdown as n, htmlToMarkdown as t };