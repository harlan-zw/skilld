import { _ as TagHandler, a as HandlerContext, b as ExtractedElement, c as MdreamRuntimeState, d as Plugin, f as PluginContext, g as TEXT_NODE, h as SplitterOptions, i as HTMLToMarkdownOptions, l as Node, m as ReadabilityContext, n as ELEMENT_NODE, o as MarkdownChunk, p as PluginCreationOptions, r as ElementNode, s as MdreamProcessingState, t as BufferRegion, u as NodeEvent, v as TailwindContext, y as TextNode } from "./_chunks/types.mjs";
import { t as createPlugin } from "./_chunks/plugin.mjs";
import { ReadableStream } from "node:stream/web";

//#region src/const.d.ts

declare const TagIdMap: {
  readonly html: 0;
  readonly head: 1;
  readonly details: 2;
  readonly summary: 3;
  readonly title: 4;
  readonly meta: 5;
  readonly br: 6;
  readonly h1: 7;
  readonly h2: 8;
  readonly h3: 9;
  readonly h4: 10;
  readonly h5: 11;
  readonly h6: 12;
  readonly hr: 13;
  readonly strong: 14;
  readonly b: 15;
  readonly em: 16;
  readonly i: 17;
  readonly del: 18;
  readonly sub: 19;
  readonly sup: 20;
  readonly ins: 21;
  readonly blockquote: 22;
  readonly code: 23;
  readonly ul: 24;
  readonly li: 25;
  readonly a: 26;
  readonly img: 27;
  readonly table: 28;
  readonly thead: 29;
  readonly tr: 30;
  readonly th: 31;
  readonly td: 32;
  readonly ol: 33;
  readonly pre: 34;
  readonly p: 35;
  readonly div: 36;
  readonly span: 37;
  readonly tbody: 38;
  readonly tfoot: 39;
  readonly form: 40;
  readonly nav: 41;
  readonly label: 42;
  readonly button: 43;
  readonly body: 44;
  readonly center: 45;
  readonly kbd: 46;
  readonly footer: 47;
  readonly path: 48;
  readonly svg: 49;
  readonly article: 50;
  readonly section: 51;
  readonly script: 52;
  readonly style: 53;
  readonly link: 54;
  readonly area: 55;
  readonly base: 56;
  readonly col: 57;
  readonly embed: 58;
  readonly input: 59;
  readonly keygen: 60;
  readonly param: 61;
  readonly source: 62;
  readonly track: 63;
  readonly wbr: 64;
  readonly select: 65;
  readonly textarea: 66;
  readonly option: 67;
  readonly fieldset: 68;
  readonly legend: 69;
  readonly audio: 70;
  readonly video: 71;
  readonly canvas: 72;
  readonly iframe: 73;
  readonly map: 74;
  readonly dialog: 75;
  readonly meter: 76;
  readonly progress: 77;
  readonly template: 78;
  readonly abbr: 79;
  readonly mark: 80;
  readonly q: 81;
  readonly samp: 82;
  readonly small: 83;
  readonly noscript: 84;
  readonly noframes: 85;
  readonly xmp: 86;
  readonly plaintext: 87;
  readonly aside: 88;
  readonly u: 89;
  readonly cite: 90;
  readonly dfn: 91;
  readonly var: 92;
  readonly time: 93;
  readonly bdo: 94;
  readonly ruby: 95;
  readonly rt: 96;
  readonly rp: 97;
  readonly dd: 98;
  readonly dt: 99;
  readonly dl: 101;
  readonly address: 100;
  readonly figure: 102;
  readonly object: 103;
  readonly main: 104;
  readonly header: 105;
  readonly figcaption: 106;
  readonly caption: 107;
};
//#endregion
//#region src/markdown-processor.d.ts
interface MarkdownState {
  /** Configuration options for conversion */
  options?: HTMLToMarkdownOptions;
  /** Map of region IDs to buffer regions for O(1) lookups */
  regionToggles: Map<number, boolean>;
  /** Content buffers for regions */
  regionContentBuffers: Map<number, string[]>;
  /** Performance cache for last content to avoid iteration */
  lastContentCache?: string;
  /** Reference to the last processed node */
  lastNode?: ElementNode | TextNode;
  /** Reference to the last processed text node - for context tracking */
  lastTextNode?: TextNode;
  /** Table processing state - specialized for Markdown tables */
  tableRenderedTable?: boolean;
  tableCurrentRowCells?: number;
  tableColumnAlignments?: string[];
  /** Map of tag names to their current nesting depth */
  depthMap: Uint8Array;
  /** Current depth for plugin access */
  depth?: number;
  /** Context for additional data */
  context?: PluginContext;
}
/**
 * Creates a markdown processor that consumes DOM events and generates markdown
 */
declare function createMarkdownProcessor(options?: HTMLToMarkdownOptions): {
  processEvent: (event: NodeEvent) => void;
  processHtml: (html: string) => void;
  getMarkdown: () => string;
  getMarkdownChunk: () => string;
  state: MarkdownState;
};
declare const MarkdownProcessor: typeof createMarkdownProcessor;
//#endregion
//#region src/parse.d.ts
interface ParseOptions {
  plugins?: Plugin[];
}
interface ParseResult {
  events: NodeEvent[];
  remainingHtml: string;
}
/**
 * Pure HTML parser that emits DOM events
 * Completely decoupled from markdown generation
 */
declare function parseHtml(html: string, options?: ParseOptions): ParseResult;
//#endregion
//#region src/stream.d.ts
/**
 * Creates a markdown stream from an HTML stream
 * @param htmlStream - ReadableStream of HTML content (as Uint8Array or string)
 * @param options - Configuration options for conversion
 * @returns An async generator yielding markdown chunks
 */
declare function streamHtmlToMarkdown(htmlStream: ReadableStream | null, options?: HTMLToMarkdownOptions): AsyncIterable<string>;
//#endregion
//#region src/index.d.ts
declare function htmlToMarkdown(html: string, options?: HTMLToMarkdownOptions): string;
//#endregion
export { BufferRegion, ELEMENT_NODE, ElementNode, ExtractedElement, HTMLToMarkdownOptions, HandlerContext, MarkdownChunk, MarkdownProcessor, MdreamProcessingState, MdreamRuntimeState, Node, NodeEvent, Plugin, PluginContext, PluginCreationOptions, ReadabilityContext, SplitterOptions, TEXT_NODE, TagHandler, TagIdMap, TailwindContext, TextNode, createPlugin, htmlToMarkdown, parseHtml, streamHtmlToMarkdown };