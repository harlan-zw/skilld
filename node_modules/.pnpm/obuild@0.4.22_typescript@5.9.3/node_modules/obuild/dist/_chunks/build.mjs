import { builtinModules } from "node:module";
import { fileURLToPath, pathToFileURL } from "node:url";
import { basename, dirname, extname, isAbsolute, join, relative, resolve } from "pathe";
import { mkdir, readFile, rm, symlink, writeFile } from "node:fs/promises";
import { consola } from "consola";
import { colors } from "consola/utils";
import { rolldown } from "rolldown";
import { dts } from "rolldown-plugin-dts";
import { minifySync, parseSync, transformSync } from "rolldown/experimental";
import { resolveModulePath } from "exsolve";
import prettyBytes from "pretty-bytes";
import { promises, readdirSync, statSync } from "node:fs";
import { gzipSync } from "node:zlib";
import { defu } from "defu";
import MagicString from "magic-string";
import { glob } from "tinyglobby";
function fmtPath(path) {
	return resolve(path).replace(process.cwd(), ".");
}
function analyzeDir(dir) {
	if (Array.isArray(dir)) {
		let totalSize = 0;
		let totalFiles = 0;
		for (const d of dir) {
			const { size, files } = analyzeDir(d);
			totalSize += size;
			totalFiles += files;
		}
		return {
			size: totalSize,
			files: totalFiles
		};
	}
	let totalSize = 0;
	const files = readdirSync(dir, {
		withFileTypes: true,
		recursive: true
	});
	for (const file of files) {
		const fullPath = join(file.parentPath, file.name);
		if (file.isFile()) {
			const { size } = statSync(fullPath);
			totalSize += size;
		}
	}
	return {
		size: totalSize,
		files: files.length
	};
}
async function distSize(dir, entry) {
	const { output } = await (await rolldown({
		input: join(dir, entry),
		plugins: [],
		platform: "neutral",
		logLevel: "silent",
		external: (id) => id[0] !== "." && !id.startsWith(dir)
	})).generate({ codeSplitting: false });
	const code = output[0].code;
	const { code: minified } = await minifySync(entry, code);
	return {
		size: Buffer.byteLength(code),
		minSize: Buffer.byteLength(minified),
		minGzipSize: gzipSync(minified).length
	};
}
async function sideEffectSize(dir, entry) {
	const { output } = await (await rolldown({
		input: "#entry",
		platform: "neutral",
		external: (id) => id[0] !== "." && !id.startsWith(dir),
		logLevel: "silent",
		plugins: [{
			name: "virtual-entry",
			async resolveId(id, importer, opts) {
				if (id === "#entry") return { id };
				const resolved = await this.resolve(id, importer, opts);
				if (!resolved) return null;
				resolved.moduleSideEffects = null;
				return resolved;
			},
			load(id) {
				if (id === "#entry") return `import * as _lib from "${join(dir, entry)}";`;
			}
		}]
	})).generate({ codeSplitting: false });
	if (process.env.INSPECT_BUILD) {
		console.log("---------[side effects]---------");
		console.log(entry);
		console.log(output[0].code);
		console.log("-------------------------------");
	}
	return Buffer.byteLength(output[0].code.trim());
}
const SHEBANG_RE = /^#![^\n]*/;
function shebangPlugin() {
	return {
		name: "obuild-shebang",
		async writeBundle(options, bundle) {
			for (const [fileName, output] of Object.entries(bundle)) {
				if (output.type !== "chunk") continue;
				if (hasShebang(output.code)) await makeExecutable(resolve(options.dir, fileName));
			}
		}
	};
}
function hasShebang(code) {
	return SHEBANG_RE.test(code);
}
async function makeExecutable(filePath) {
	await promises.chmod(filePath, 493).catch(() => {});
}
async function rolldownBuild(ctx, entry, hooks) {
	const inputs = normalizeBundleInputs(entry.input, ctx);
	if (entry.stub) {
		for (const [distName, srcPath] of Object.entries(inputs)) {
			const distPath = join(ctx.pkgDir, "dist", `${distName}.mjs`);
			await mkdir(dirname(distPath), { recursive: true });
			consola.log(`${colors.magenta("[bundle] ")} ${colors.underline(fmtPath(distPath))} ${colors.dim("(stub)")}`);
			const srcContents = await readFile(srcPath, "utf8");
			const hasDefaultExport = parseSync(srcPath, srcContents).module.staticExports.flatMap((e) => e.entries.map((e) => e.exportName.kind === "Default" ? "default" : e.exportName.name)).includes("default");
			const firstLine = srcContents.split("\n")[0];
			const hasShebangLine = firstLine.startsWith("#!");
			const relativeSrcPath = relative(dirname(distPath), srcPath);
			await writeFile(distPath, `${hasShebangLine ? firstLine + "\n" : ""}export * from "${relativeSrcPath}";\n${hasDefaultExport ? `export { default } from "${relativeSrcPath}";\n` : ""}`, "utf8");
			if (hasShebangLine) await makeExecutable(distPath);
			await writeFile(distPath.replace(/\.mjs$/, ".d.mts"), `export * from "${relativeSrcPath}";\n${hasDefaultExport ? `export { default } from "${relativeSrcPath}";\n` : ""}`, "utf8");
		}
		return;
	}
	const rolldownConfig = defu(entry.rolldown, {
		cwd: ctx.pkgDir,
		input: inputs,
		plugins: [shebangPlugin()],
		platform: "node",
		onLog(level, log, defaultHandler) {
			if (log.code === "EVAL") return;
			defaultHandler(level, log);
		},
		external: [
			...builtinModules,
			...builtinModules.map((m) => `node:${m}`),
			...[...Object.keys(ctx.pkg.dependencies || {}), ...Object.keys(ctx.pkg.peerDependencies || {})].flatMap((p) => [p, new RegExp(`^${p}/`)])
		]
	});
	if (entry.dts !== false) rolldownConfig.plugins.push(...dts({ ...entry.dts }));
	await hooks.rolldownConfig?.(rolldownConfig, ctx);
	const res = await rolldown(rolldownConfig);
	const outDir = resolve(ctx.pkgDir, entry.outDir || "dist");
	const outConfig = {
		dir: outDir,
		format: "esm",
		entryFileNames: "[name].mjs",
		chunkFileNames: "_chunks/[name].mjs",
		minify: entry.minify ?? "dce-only",
		codeSplitting: { groups: [{
			test: /node_modules/,
			name: (moduleId) => {
				const pkgName = moduleId.match(/.*\/node_modules\/(?<package>@[^/]+\/[^/]+|[^/]+)/)?.groups?.package;
				const isDts = /\.d\.[mc]?ts$/.test(moduleId);
				return `libs/${pkgName || "common"}${isDts ? ".d" : ""}`;
			}
		}] }
	};
	await hooks.rolldownOutput?.(outConfig, res, ctx);
	const { output } = await res.write(outConfig);
	await res.close();
	const outputEntries = [];
	const depsCache = /* @__PURE__ */ new Map();
	const resolveDeps = (chunk) => {
		let deps = depsCache.get(chunk);
		if (deps) return [...deps].sort();
		deps = /* @__PURE__ */ new Set();
		depsCache.set(chunk, deps);
		for (const id of chunk.imports) {
			if (builtinModules.includes(id) || id.startsWith("node:")) {
				deps.add(`[Node.js]`);
				continue;
			}
			const depChunk = output.find((o) => o.type === "chunk" && o.fileName === id);
			if (depChunk) {
				for (const dep of resolveDeps(depChunk)) deps.add(dep);
				continue;
			}
			deps.add(id);
		}
		return [...deps].sort();
	};
	for (const chunk of output) {
		if (chunk.type !== "chunk" || !chunk.isEntry) continue;
		if (chunk.fileName.endsWith("ts")) continue;
		outputEntries.push({
			name: chunk.fileName,
			exports: chunk.exports,
			deps: resolveDeps(chunk),
			...await distSize(outDir, chunk.fileName),
			sideEffectSize: await sideEffectSize(outDir, chunk.fileName)
		});
	}
	consola.log(`\n${outputEntries.map((o) => [
		colors.magenta(`[bundle] `) + `${colors.underline(fmtPath(join(outDir, o.name)))}`,
		colors.dim(`${colors.bold("Size:")} ${prettyBytes(o.size)}, ${colors.bold(prettyBytes(o.minSize))} minified, ${prettyBytes(o.minGzipSize)} min+gzipped (Side effects: ${prettyBytes(o.sideEffectSize)})`),
		o.exports.some((e) => e !== "default") ? colors.dim(`${colors.bold("Exports:")} ${o.exports.map((e) => e).join(", ")}`) : "",
		o.deps.length > 0 ? colors.dim(`${colors.bold("Dependencies:")} ${o.deps.join(", ")}`) : ""
	].filter(Boolean).join("\n")).join("\n\n")}`);
}
function normalizeBundleInputs(input, ctx) {
	const inputs = {};
	for (let src of Array.isArray(input) ? input : [input]) {
		src = resolveModulePath(src, {
			from: ctx.pkgDir,
			extensions: [
				".ts",
				".js",
				".mjs",
				".cjs",
				".json"
			]
		});
		let relativeSrc = relative(join(ctx.pkgDir, "src"), src);
		if (relativeSrc.startsWith("..")) relativeSrc = relative(join(ctx.pkgDir), src);
		if (relativeSrc.startsWith("..")) throw new Error(`Source should be within the package directory (${ctx.pkgDir}): ${src}`);
		const distName = join(dirname(relativeSrc), basename(relativeSrc, extname(relativeSrc)));
		if (inputs[distName]) throw new Error(`Rename one of the entries to avoid a conflict in the dist name "${distName}":\n - ${src}\n - ${inputs[distName]}`);
		inputs[distName] = src;
	}
	return inputs;
}
async function transformDir(ctx, entry) {
	const promises = [];
	for await (const entryName of await glob("**/*.*", { cwd: entry.input })) {
		if (entry.filter && await entry.filter(entryName) === false) continue;
		promises.push((async () => {
			const entryPath = join(entry.input, entryName);
			switch (extname(entryPath)) {
				case ".ts": {
					const entryDistPath = join(entry.outDir, entryName.replace(/\.ts$/, ".mjs"));
					const transformed = await transformModule(entryPath, entry, entryDistPath);
					await mkdir(dirname(entryDistPath), { recursive: true });
					await writeFile(entryDistPath, transformed.code, "utf8");
					if (SHEBANG_RE.test(transformed.code)) await makeExecutable(entryDistPath);
					if (transformed.declaration) await writeFile(entryDistPath.replace(/\.mjs$/, ".d.mts"), transformed.declaration, "utf8");
					return entryDistPath;
				}
				default: {
					const entryDistPath = join(entry.outDir, entryName);
					await mkdir(dirname(entryDistPath), { recursive: true });
					if (entry.stub) await symlink(entryPath, entryDistPath, "junction").catch(() => {});
					else {
						const code = await readFile(entryPath, "utf8");
						await writeFile(entryDistPath, code, "utf8");
						if (SHEBANG_RE.test(code)) await makeExecutable(entryDistPath);
					}
					return entryDistPath;
				}
			}
		})());
	}
	const writtenFiles = await Promise.all(promises);
	consola.log(`\n${colors.magenta("[transform] ")}${colors.underline(fmtPath(entry.outDir) + "/")}${entry.stub ? colors.dim(" (stub)") : ""}\n${colors.dim(itemsTable(writtenFiles.map((f) => fmtPath(f))))}`);
}
function itemsTable(items, consoleWidth = process.stdout.columns || 80) {
	if (items.length === 0) return "";
	const colWidth = Math.max(...items.map((item) => item.length)) + 2;
	const columns = Math.max(1, Math.floor(consoleWidth / colWidth));
	const rows = [];
	for (let i = 0; i < items.length; i += columns) {
		const row = items.slice(i, i + columns);
		rows.push(row.map((item) => item.padEnd(colWidth)).join(""));
	}
	return rows.join("\n");
}
async function transformModule(entryPath, entry, entryDistPath) {
	let sourceText = await readFile(entryPath, "utf8");
	const sourceOptions = {
		lang: "ts",
		sourceType: "module"
	};
	const parsed = parseSync(entryPath, sourceText, { ...sourceOptions });
	if (entry.stub) {
		const hasDefaultExport = parsed?.module?.staticExports?.find((exp) => exp.entries.some((e) => e.exportName.kind === "Default")) !== void 0;
		const relativePath = relative(dirname(entryDistPath), entryPath);
		const code = `export * from "${relativePath}";${hasDefaultExport ? `\nexport { default } from "${relativePath}";` : ""}`;
		return {
			code,
			declaration: code
		};
	}
	if (parsed.errors.length > 0) throw new Error(`Errors while parsing ${entryPath}:`, { cause: parsed.errors });
	const resolveOptions = {
		...entry.resolve,
		from: pathToFileURL(entryPath),
		extensions: entry.resolve?.extensions ?? [
			".ts",
			".js",
			".mjs",
			".cjs",
			".json"
		],
		suffixes: entry.resolve?.suffixes ?? ["", "/index"]
	};
	const magicString = new MagicString(sourceText);
	const updatedStarts = /* @__PURE__ */ new Set();
	const rewriteSpecifier = (req) => {
		const moduleId = req.value;
		if (!moduleId.startsWith(".")) return;
		if (updatedStarts.has(req.start)) return;
		updatedStarts.add(req.start);
		const resolvedAbsolute = resolveModulePath(moduleId, resolveOptions);
		const newId = relative(dirname(entryPath), resolvedAbsolute.replace(/\.ts$/, ".mjs"));
		magicString.remove(req.start, req.end);
		magicString.prependLeft(req.start, JSON.stringify(newId.startsWith(".") ? newId : `./${newId}`));
	};
	for (const staticImport of parsed.module.staticImports) rewriteSpecifier(staticImport.moduleRequest);
	for (const staticExport of parsed.module.staticExports) for (const staticExportEntry of staticExport.entries) if (staticExportEntry.moduleRequest) rewriteSpecifier(staticExportEntry.moduleRequest);
	sourceText = magicString.toString();
	const transformed = transformSync(entryPath, sourceText, {
		...entry.oxc,
		...sourceOptions,
		cwd: dirname(entryPath),
		typescript: {
			declaration: { stripInternal: true },
			...entry.oxc?.typescript
		}
	});
	const transformErrors = transformed.errors.filter((err) => !err.message.includes("--isolatedDeclarations"));
	if (transformErrors.length > 0) {
		await writeFile("build-dump.ts", `/** Error dump for ${entryPath} */\n\n` + sourceText, "utf8");
		throw new Error(`Errors while transforming ${entryPath}: (hint: check build-dump.ts)`, { cause: transformErrors });
	}
	if (entry.minify) {
		const res = minifySync(entryPath, transformed.code, entry.minify === true ? {} : entry.minify);
		transformed.code = res.code;
		transformed.map = res.map;
	}
	return transformed;
}
async function build(config) {
	const start = Date.now();
	const pkgDir = normalizePath(config.cwd);
	const ctx = {
		pkg: await readJSON(join(pkgDir, "package.json")).catch(() => ({})),
		pkgDir
	};
	consola.log(`ðŸ“¦ Building \`${ctx.pkg.name || "<no name>"}\` (\`${ctx.pkgDir}\`)`);
	const hooks = config.hooks || {};
	await hooks.start?.(ctx);
	const entries = (config.entries || []).map((rawEntry) => {
		let entry;
		if (typeof rawEntry === "string") {
			const [input, outDir] = rawEntry.split(":");
			entry = input.endsWith("/") ? {
				type: "transform",
				input,
				outDir
			} : {
				type: "bundle",
				input: input.split(","),
				outDir
			};
		} else entry = rawEntry;
		if (!entry.input) throw new Error(`Build entry missing \`input\`: ${JSON.stringify(entry, null, 2)}`);
		entry = { ...entry };
		entry.outDir = normalizePath(entry.outDir || "dist", pkgDir);
		entry.input = Array.isArray(entry.input) ? entry.input.map((p) => normalizePath(p, pkgDir)) : normalizePath(entry.input, pkgDir);
		return entry;
	});
	await hooks.entries?.(entries, ctx);
	const outDirs = [];
	for (const outDir of entries.map((e) => e.outDir).sort()) if (!outDirs.some((dir) => outDir.startsWith(dir))) outDirs.push(outDir);
	for (const outDir of outDirs) {
		consola.log(`ðŸ§» Cleaning up \`${fmtPath(outDir)}\``);
		await rm(outDir, {
			recursive: true,
			force: true
		});
	}
	for (const entry of entries) await (entry.type === "bundle" ? rolldownBuild(ctx, entry, hooks) : transformDir(ctx, entry));
	await hooks.end?.(ctx);
	if (!entries.every((e) => e.stub)) {
		const dirSize = analyzeDir(outDirs);
		consola.log(colors.dim(`\nÎ£ Total dist byte size: ${colors.underline(prettyBytes(dirSize.size))} (${colors.underline(dirSize.files)} files)`));
	}
	consola.log(`\nâœ… obuild finished in ${Date.now() - start}ms`);
}
function normalizePath(path, resolveFrom) {
	return typeof path === "string" && isAbsolute(path) ? path : path instanceof URL ? fileURLToPath(path) : resolve(resolveFrom || ".", path || ".");
}
function readJSON(specifier) {
	return import(specifier, { with: { type: "json" } }).then((r) => r.default);
}
export { build as t };
